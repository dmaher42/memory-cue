<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <base href="/memory-cue/" />
  <!-- Production CSS: compiled via Tailwind/PostCSS; build rewrites this to a hashed asset -->
  <link rel="stylesheet" href="./styles/index.css" />
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
  />
  <title>Memory Cue (Mobile)</title>
  <meta name="theme-color" content="#0f172a" />
  <link rel="manifest" href="./manifest.webmanifest" id="manifestLink" />
  <link rel="icon" href="./icons/icon-192.svg" type="image/svg+xml" />
  <link rel="stylesheet" href="./styles/tokens.css" />
  <link rel="stylesheet" href="./styles/a11y.css" />
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/daisyui@4.12.10/dist/full.min.css"
    integrity="sha384-yxrQVVFFRZdq4Z/YbeTDzSYbn1W6VnVonm2vAgnxtxUMehcccE4k2NufOz2tJnOe"
    crossorigin="anonymous"
  />
  <link rel="stylesheet" href="./styles/daisy-themes.css" />
  <style>
    /* Accessibility helper */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    /* Status dot colors */
    .sync-dot {
      font-size: 14px;
      line-height: 1;
      transition: color 0.2s ease;
    }
    .sync-dot.online {
      color: #16a34a;
    }
    .sync-dot.offline {
      color: #dc2626;
    }
    .sync-status-indicator {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.25rem 0.55rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 600;
      line-height: 1;
      background: rgba(15, 23, 42, 0.06);
      color: rgba(71, 85, 105, 0.9);
      transition: background-color 0.2s ease, color 0.2s ease;
    }

    .dark .sync-status-indicator {
      background: rgba(148, 163, 184, 0.18);
      color: rgba(226, 232, 240, 0.9);
    }

    .sync-status-indicator.online {
      background: rgba(34, 197, 94, 0.15);
      color: rgba(22, 163, 74, 0.92);
    }

    .sync-status-indicator.offline,
    .sync-status-indicator.error {
      background: rgba(248, 113, 113, 0.16);
      color: rgba(220, 38, 38, 0.92);
    }

    .sync-dot {
      display: inline-block;
      width: 0.55rem;
      height: 0.55rem;
      border-radius: 9999px;
      background: rgba(220, 38, 38, 0.9);
      transition: background-color 0.2s ease, box-shadow 0.2s ease;
    }

    .sync-dot.online {
      background: rgba(22, 163, 74, 0.9);
      box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.18);
    }
    /* Compact quick add optimizations */
    #quickAddBar {
      margin-bottom: 12px;
    }

    #quickAddBar > div {
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(248, 250, 252, 0.85));
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border: 1px solid rgba(0, 0, 0, 0.06);
      box-shadow: 0 8px 24px rgba(15, 23, 42, 0.08);
      border-radius: 16px;
      position: relative;
      overflow: hidden;
    }

    #quickAddBar > div::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top, rgba(255, 255, 255, 0.6), transparent 55%);
      pointer-events: none;
      mix-blend-mode: screen;
      opacity: 0.7;
    }

    #quickAddBar > div::after {
      content: "";
      position: absolute;
      inset: 1px;
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.55);
      pointer-events: none;
    }

    .dark #quickAddBar > div {
      background: linear-gradient(135deg, rgba(30, 41, 59, 0.9), rgba(15, 23, 42, 0.85));
      border-color: rgba(255, 255, 255, 0.08);
      box-shadow: 0 10px 28px rgba(15, 23, 42, 0.35);
    }

    .dark #quickAddBar > div::before {
      background: radial-gradient(circle at top, rgba(148, 163, 184, 0.35), transparent 60%);
      mix-blend-mode: screen;
    }

    .dark #quickAddBar > div::after {
      border-color: rgba(148, 163, 184, 0.2);
    }

    #quickAddInput {
      font-size: 15px;
      line-height: 1.4;
      color: inherit;
      min-height: 36px;
    }

    #quickAddInput::placeholder {
      color: rgba(100, 116, 139, 0.5);
    }

    .dark #quickAddInput::placeholder {
      color: rgba(203, 213, 225, 0.5);
    }

    #quickAddInput:focus {
      outline: none;
      box-shadow: none;
    }

    /* Compact voice button */
    #quickAddVoiceBtn {
      min-width: 32px;
      min-height: 32px;
      border-radius: 8px;
    }

    #quickAddVoiceBtn:active {
      transform: scale(0.95);
    }

    #quickAddVoiceBtn.listening {
      background: rgba(239, 68, 68, 0.1);
      color: rgba(239, 68, 68, 0.9);
    }

    /* Compact submit button */
    #quickAddSubmit {
      min-height: 32px;
      font-weight: 600;
      letter-spacing: 0.01em;
      box-shadow: 0 2px 4px rgba(16, 185, 129, 0.2);
    }

    #quickAddSubmit:hover {
      box-shadow: 0 3px 6px rgba(16, 185, 129, 0.3);
    }

    #quickAddSubmit:active {
      box-shadow: 0 1px 2px rgba(16, 185, 129, 0.2);
    }

    /* Responsive adjustments */
    @media (max-width: 380px) {
      #quickAddBar > div {
        padding: 8px 12px;
      }

      #quickAddInput {
        font-size: 14px;
      }

      #quickAddSubmit {
        padding: 6px 10px;
        font-size: 13px;
      }
    }

    /* Focus states for accessibility */
    #quickAddVoiceBtn:focus-visible {
      outline: 2px solid rgba(59, 130, 246, 0.5);
      outline-offset: 1px;
    }

    #quickAddSubmit:focus-visible {
      outline: 2px solid rgba(59, 130, 246, 0.5);
      outline-offset: 1px;
    }
    .notes-editor {
      min-height: 10rem;
      width: 100%;
      border-radius: 0.75rem;
      border: 1px solid rgba(148, 163, 184, 0.5);
      padding: 0.75rem 1rem;
      background-color: rgba(255, 255, 255, 0.9);
      color: inherit;
      white-space: pre-wrap;
      overflow-wrap: break-word;
      line-height: 1.5;
      outline: none;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .dark .notes-editor {
      border-color: rgba(148, 163, 184, 0.35);
      background-color: rgba(15, 23, 42, 0.65);
    }
    .notes-editor:focus-visible {
      border-color: rgb(37 99 235);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
    }
    .notes-editor:empty::before {
      content: attr(data-placeholder);
      color: rgba(100, 116, 139, 0.7);
    }
    .dark .notes-editor:empty::before {
      color: rgba(148, 163, 184, 0.7);
    }
    .notes-editor ul,
    .notes-editor ol {
      margin: 0.25rem 0 0.25rem 1.25rem;
      padding-left: 0.75rem;
    }
    .notes-editor ul li,
    .notes-editor ol li {
      margin-bottom: 0.25rem;
    }
    .notes-editor--columns {
      column-width: 16rem;
      column-gap: 1.5rem;
    }
    .view-panel {
      display: grid;
      gap: 1.5rem;
    }
    .section-jump {
      display: flex;
      gap: 0.5rem;
      overflow-x: auto;
      padding-bottom: 0.25rem;
      scrollbar-width: none;
      scroll-snap-type: x proximity;
    }
    .section-jump::-webkit-scrollbar {
      display: none;
    }
    .section-jump .btn {
      scroll-snap-align: start;
    }
    .glass-panel {
      background-color: rgba(248, 250, 252, 0.85);
      backdrop-filter: blur(12px);
    }
    .dark .glass-panel {
      background-color: rgba(15, 23, 42, 0.88);
    }
    /* Enhanced reminder visibility styles */
    .task-item {
      position: relative;
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 1rem;
      align-items: start;
      padding: 1rem;
      padding-left: 1.25rem;
      margin-bottom: 0.75rem;
      background: rgba(255, 255, 255, 0.95);
      border: 1px solid rgba(148, 163, 184, 0.3);
      border-left-width: 4px;
      border-left-color: rgba(99, 102, 241, 0.6);
      border-radius: 0.75rem;
      box-shadow: 0 2px 8px rgba(15, 23, 42, 0.08), 0 1px 3px rgba(15, 23, 42, 0.06);
      transition: all 0.2s ease;
    }
    .task-item:hover {
      border-left-color: rgba(99, 102, 241, 0.9);
      box-shadow: 0 4px 12px rgba(15, 23, 42, 0.12), 0 2px 6px rgba(15, 23, 42, 0.08);
      transform: translateY(-1px);
    }
    .dark .task-item {
      background: rgba(30, 41, 59, 0.85);
      border-color: rgba(148, 163, 184, 0.25);
      border-left-color: rgba(129, 140, 248, 0.7);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2), 0 1px 3px rgba(0, 0, 0, 0.15);
    }
    .dark .task-item:hover {
      border-left-color: rgba(129, 140, 248, 1);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3), 0 2px 6px rgba(0, 0, 0, 0.2);
    }
    .task-item[data-priority="High"] {
      border-left-color: rgba(239, 68, 68, 0.7);
      background: linear-gradient(135deg, rgba(254, 226, 226, 0.4), rgba(255, 255, 255, 0.95));
    }
    .dark .task-item[data-priority="High"] {
      border-left-color: rgba(248, 113, 113, 0.8);
      background: linear-gradient(135deg, rgba(127, 29, 29, 0.3), rgba(30, 41, 59, 0.85));
    }
    .task-item[data-priority="Medium"] {
      border-left-color: rgba(245, 158, 11, 0.7);
      background: linear-gradient(135deg, rgba(254, 243, 199, 0.35), rgba(255, 255, 255, 0.95));
    }
    .dark .task-item[data-priority="Medium"] {
      border-left-color: rgba(251, 191, 36, 0.8);
      background: linear-gradient(135deg, rgba(120, 53, 15, 0.25), rgba(30, 41, 59, 0.85));
    }
    .task-item[data-priority="Low"] {
      border-left-color: rgba(34, 197, 94, 0.7);
      background: linear-gradient(135deg, rgba(220, 252, 231, 0.35), rgba(255, 255, 255, 0.95));
    }
    .dark .task-item[data-priority="Low"] {
      border-left-color: rgba(74, 222, 128, 0.8);
      background: linear-gradient(135deg, rgba(20, 83, 45, 0.25), rgba(30, 41, 59, 0.85));
    }
    .task-content {
      min-width: 0;
      text-align: left;
      flex: 1 1 auto;
    }
    .task-title,
    .task-meta,
    .task-notes {
      text-align: left;
    }
    .task-title {
      font-size: 1.0625rem;
      font-weight: 600;
      line-height: 1.4;
      color: rgba(15, 23, 42, 0.95);
      margin-bottom: 0.5rem;
    }
    .dark .task-title {
      color: rgba(241, 245, 249, 0.95);
    }
    .task-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      font-size: 0.8125rem;
    }
    .task-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.25rem 0.625rem;
      border-radius: 9999px;
      background: rgba(148, 163, 184, 0.15);
      color: rgba(71, 85, 105, 0.9);
      font-size: 0.75rem;
      font-weight: 600;
      letter-spacing: 0.01em;
      line-height: 1.3;
      border: 1px solid rgba(148, 163, 184, 0.2);
    }
    .dark .task-chip {
      background: rgba(71, 85, 105, 0.3);
      color: rgba(203, 213, 225, 0.9);
      border-color: rgba(71, 85, 105, 0.4);
    }
    .task-chip[data-chip="priority"] {
      font-weight: 700;
      background: rgba(99, 102, 241, 0.12);
      color: rgba(67, 56, 202, 0.95);
      border-color: rgba(99, 102, 241, 0.25);
    }
    .dark .task-chip[data-chip="priority"] {
      background: rgba(129, 140, 248, 0.2);
      color: rgba(165, 180, 252, 0.95);
      border-color: rgba(129, 140, 248, 0.3);
    }
    .task-item[data-priority="High"] .task-chip[data-chip="priority"] {
      background: rgba(239, 68, 68, 0.15);
      color: rgba(185, 28, 28, 0.95);
      border-color: rgba(239, 68, 68, 0.3);
    }
    .dark .task-item[data-priority="High"] .task-chip[data-chip="priority"] {
      background: rgba(248, 113, 113, 0.2);
      color: rgba(252, 165, 165, 0.95);
      border-color: rgba(248, 113, 113, 0.35);
    }
    .task-item[data-priority="Medium"] .task-chip[data-chip="priority"] {
      background: rgba(245, 158, 11, 0.15);
      color: rgba(161, 98, 7, 0.95);
      border-color: rgba(245, 158, 11, 0.3);
    }
    .dark .task-item[data-priority="Medium"] .task-chip[data-chip="priority"] {
      background: rgba(251, 191, 36, 0.2);
      color: rgba(253, 224, 71, 0.95);
      border-color: rgba(251, 191, 36, 0.35);
    }
    .task-item[data-priority="Low"] .task-chip[data-chip="priority"] {
      background: rgba(34, 197, 94, 0.15);
      color: rgba(21, 128, 61, 0.95);
      border-color: rgba(34, 197, 94, 0.3);
    }
    .dark .task-item[data-priority="Low"] .task-chip[data-chip="priority"] {
      background: rgba(74, 222, 128, 0.2);
      color: rgba(134, 239, 172, 0.95);
      border-color: rgba(74, 222, 128, 0.35);
    }
    .task-notes {
      margin-top: 0.5rem;
      padding-top: 0.5rem;
      border-top: 1px solid rgba(148, 163, 184, 0.15);
      font-size: 0.875rem;
      line-height: 1.5;
      color: rgba(71, 85, 105, 0.85);
    }
    .dark .task-notes {
      border-top-color: rgba(71, 85, 105, 0.3);
      color: rgba(203, 213, 225, 0.8);
    }
    .task-actions {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      justify-content: flex-end;
      margin-top: auto;
      padding-top: 0.75rem;
    }
    .task-actions button {
      padding: 0.375rem 0.75rem;
      font-size: 0.8125rem;
      font-weight: 600;
      border-radius: 0.5rem;
      transition: all 0.15s ease;
      color: rgba(30, 41, 59, 0.88);
    }
    .task-actions button:hover,
    .task-actions button:focus-visible {
      color: rgba(30, 41, 59, 1);
    }
    .dark .task-actions button {
      color: rgba(226, 232, 240, 0.92);
    }
    .dark .task-actions button:hover,
    .dark .task-actions button:focus-visible {
      color: rgba(248, 250, 252, 1);
    }
    /* Today-specific task styling - more prominent */
    .task-item[data-today="true"],
    .task-item.is-today {
      border-color: rgba(59, 130, 246, 0.45);
      border-left-color: rgba(37, 99, 235, 0.85);
      background: linear-gradient(135deg, rgba(191, 219, 254, 0.35), rgba(191, 219, 254, 0.12));
      box-shadow: 0 4px 14px rgba(30, 64, 175, 0.25), 0 2px 6px rgba(30, 64, 175, 0.15);
    }
    .dark .task-item[data-today="true"],
    .dark .task-item.is-today {
      border-color: rgba(96, 165, 250, 0.55);
      border-left-color: rgba(191, 219, 254, 0.9);
      background: linear-gradient(135deg, rgba(30, 64, 175, 0.45), rgba(30, 58, 138, 0.3));
      box-shadow: 0 4px 14px rgba(30, 64, 175, 0.4), 0 2px 6px rgba(30, 64, 175, 0.25);
    }

    /* Mobile-first optimizations */
    :root {
      --mobile-header-height: 120px;
      --mobile-safe-area-top: env(safe-area-inset-top, 0px);
      --mobile-safe-area-bottom: env(safe-area-inset-bottom, 0px);
    }

    /* Enhanced mobile body */
    body {
      overscroll-behavior: contain;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      touch-action: manipulation;
    }

    /* Mobile main container */
    main {
      padding-top: 0;
      padding-bottom: calc(32px + var(--mobile-safe-area-bottom));
      min-height: calc(100vh - var(--mobile-header-height));
      scroll-padding-top: calc(var(--mobile-header-height) + 16px);
    }

    /* Mobile task items */
    .task-item {
      margin-bottom: 16px;
      padding: 16px;
      border-radius: 16px;
      border-left-width: 4px;
      min-height: 80px;
      transition: all 0.2s ease;
      transform: translateZ(0);
      display: flex;
      flex-direction: column;
    }

    .task-item:active {
      transform: scale(0.98);
    }

    /* Mobile cards */
    .card {
      border-radius: 16px;
      border: 1px solid rgba(0, 0, 0, 0.06);
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.98), rgba(248, 250, 252, 0.98));
      backdrop-filter: blur(8px);
    }

    .dark .card {
      background: linear-gradient(135deg, rgba(30, 41, 59, 0.98), rgba(15, 23, 42, 0.98));
      border-color: rgba(255, 255, 255, 0.08);
    }

    /* Mobile buttons */
    .btn {
      min-height: 44px;
      border-radius: 12px;
      font-weight: 600;
    }

    /* Responsive reminder grid */
    #reminderList {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    /* 2-column layout on wider phones */
    @media (min-width: 380px) {
      #reminderList.grid-cols-2 {
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
    }

    /* Adjust task items for grid layout */
    #reminderList.grid-cols-2 .task-item {
      margin-bottom: 0 !important;
      padding: 12px;
      padding-left: 14px;
      min-height: 80px;
      display: flex;
      flex-direction: column;
    }

    /* Truncate long content for grid layout */
    #reminderList.grid-cols-2 .task-title {
      font-size: 14px;
      line-height: 1.3;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
      margin-bottom: 8px;
    }

    #reminderList.grid-cols-2 .task-notes {
      display: -webkit-box;
      -webkit-line-clamp: 1;
      -webkit-box-orient: vertical;
      overflow: hidden;
      font-size: 12px;
      line-height: 1.3;
    }

    /* Compact task meta for grid */
    #reminderList.grid-cols-2 .task-meta {
      font-size: 11px;
      gap: 4px;
      margin-top: auto;
    }

    #reminderList.grid-cols-2 .task-chip {
      padding: 2px 6px;
      font-size: 10px;
    }

    /* Adjust task actions for grid */
    #reminderList.grid-cols-2 .task-actions {
      gap: 4px;
      padding-top: 0.5rem;
      justify-content: flex-end;
    }

    #reminderList.grid-cols-2 .task-actions button {
      width: 28px;
      height: 28px;
      font-size: 12px;
      padding: 0;
    }

    /* Compact priority indicators */
    #reminderList.grid-cols-2 .task-item {
      border-left-width: 3px;
      border-radius: 12px;
    }

    /* Hide some elements in grid mode for space */
    .task-item[data-compact="true"] .task-notes {
      display: none;
    }

    .task-item[data-compact="true"] .task-meta {
      display: flex;
      gap: 4px;
    }

    .task-item[data-compact="true"] .task-chip:not([data-chip="priority"]) {
      display: none;
    }

    /* Single column on narrow phones */
    @media (max-width: 379px) {
      #reminderList.grid-cols-2 {
        grid-template-columns: 1fr;
      }

      #reminderList.grid-cols-2 .task-item {
        padding: 16px;
        padding-left: 18px;
        border-left-width: 4px;
      }

      #reminderList.grid-cols-2 .task-title {
        font-size: 15px;
        -webkit-line-clamp: 3;
      }
    }

    /* Optional: Add view toggle button */
    .view-toggle {
      position: absolute;
      top: 16px;
      right: 16px;
      z-index: 10;
    }
  </style>
  <!-- Skip-link CSS: fully hidden until keyboard focus -->
  <style id="skip-link-css">
    .skip-link {
      position: absolute;
      left: -9999px;
      top: auto;
      width: 1px;
      height: 1px;
      overflow: hidden;
    }
    .skip-link:focus-visible {
      left: 16px;
      top: 16px;
      width: auto;
      height: auto;
      overflow: visible;
      z-index: 50;
      border-radius: 9999px; padding: 8px 12px;
      background: var(--fallback-p, #2563eb); color: var(--fallback-pc, #fff);
      box-shadow: 0 2px 6px rgba(0,0,0,.15);
    }
  </style>
  <!-- BEGIN GPT CHANGE: bottom sheet styles -->
  <style>
    :root {
      --vh: 1vh;
    }

    body,
    .min-h-screen {
      min-height: calc(var(--vh, 1vh) * 100);
    }

    .hidden {
      display: none !important;
    }
    .sheet {
      position: fixed;
      inset: 0;
      min-height: calc(var(--vh, 1vh) * 100);
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      z-index: 90;
    }
    .sheet-panel {
      position: relative;
      left: 0;
      right: 0;
      bottom: 0;
      max-height: calc(var(--vh, 1vh) * 85);
      overflow: auto;
      border-top-left-radius: 16px;
      border-top-right-radius: 16px;
      background: var(--fallback-b1, #ffffff);
      color: inherit;
      box-shadow: 0 -16px 32px rgba(15, 23, 42, 0.25);
      padding: 16px;
    }
    .dark .sheet-panel {
      background: rgba(30, 41, 59, 0.97);
    }
    .sheet-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding-bottom: 12px;
      gap: 12px;
    }
    .sheet-header-actions {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .sheet-header-actions .btn.is-listening {
      background: var(--fallback-p, #2563eb);
      color: var(--fallback-pc, #fff);
    }
    .sheet-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(15, 23, 42, 0.45);
    }
    #settingsModal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 80;
    }
    .modal-panel {
      position: relative;
      max-width: 420px;
      width: calc(100% - 32px);
      background: var(--fallback-b1, #ffffff);
      color: inherit;
      border-radius: 16px;
      box-shadow: 0 20px 40px rgba(15, 23, 42, 0.3);
      overflow: hidden;
    }
    .dark .modal-panel {
      background: rgba(30, 41, 59, 0.97);
    }
    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.3);
    }
    .modal-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(15, 23, 42, 0.55);
    }
  </style>
  <style id="add-task-stability-css">
    /* Make sure modal/sheet stays interactive and above other layers */
    [data-add-task-dialog] {
      position: fixed;
      inset: 0;
      z-index: 60;
    }
    [data-add-task-dialog] [data-dialog-content] {
      position: relative;
      z-index: 61;
      pointer-events: auto;
    }
    /* Backdrop element (if you have one) should sit under content but accept clicks */
    [data-add-task-dialog] .backdrop {
      position: absolute;
      inset: 0;
      z-index: 59;
    }
  </style>
  <!-- END GPT CHANGE: bottom sheet styles -->
  <!-- BEGIN GPT CHANGE: rhythm -->
  <style>
    .card-body.compact {
      gap: 0.5rem;
    }
    .inputs-compact input,
    .inputs-compact select,
    .inputs-compact textarea,
    .inputs-compact button {
      padding-top: 8px;
      padding-bottom: 8px;
    }
    main {
      padding-bottom: 96px;
    }
    .chip-row {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .chip-row label {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 6px 12px;
      border-radius: 9999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      cursor: pointer;
      font-size: 0.875rem;
    }
    .chip-row input[type='radio'] {
      accent-color: currentColor;
    }
    .voice-add-wrap {
      display: none !important;
    }
    .focus-list,
    .focus-detail {
      display: none !important;
    }
    #toggleUiBtn {
      display: none !important;
    }
  </style>
  <!-- END GPT CHANGE: rhythm -->
  <style id="min-expand-css">
    /* Expand/collapse behavior */
    .task-row-min {
      cursor: pointer;
      outline: none;
    }
    .task-row-min:focus {
      box-shadow: 0 0 0 2px rgba(0,0,0,.15) inset;
    }
    .task-row-min .min-notes {
      display: none;
      grid-column: 1 / -1;
      margin-top: 8px;
      font-size: 14px;
      line-height: 1.35;
      opacity: .95;
      white-space: pre-wrap;
    }
    .task-row-min.expanded .min-notes {
      display: block;
    }
    /* Slightly larger title when expanded */
    .task-row-min.expanded .title {
      font-weight: 600;
    }
    /* Optional small chevron indicator */
    .task-row-min::after {
      content: "‚ñæ";
      justify-self: end;
      opacity: .5;
      font-size: 12px;
    }
    .task-row-min.expanded::after { transform: rotate(180deg); }

  </style>
  <style id="empty-state-compact-css">
    #emptyState {
      text-align: left;
    }
    #emptyState .empty-state-compact {
      display: grid;
      gap: 0.75rem;
      justify-items: start;
      text-align: left;
      width: 100%;
    }
    #emptyState .empty-state-compact h3 {
      font-size: 1rem;
      font-weight: 600;
      line-height: 1.4;
    }
    #emptyState .empty-state-compact p {
      font-size: 0.875rem;
      line-height: 1.5;
      color: rgba(71, 85, 105, 0.85);
    }
    .dark #emptyState .empty-state-compact p {
      color: rgba(226, 232, 240, 0.8);
    }
    #emptyState .empty-state-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      width: 100%;
    }
    #emptyState .empty-state-actions > * {
      flex: 1 1 auto;
    }
  </style>
</head>
<body class="min-h-screen bg-base-200 text-base-content show-full">
  <a class="sr-only focus:not-sr-only focus:fixed focus:left-4 focus:top-4 focus:z-50 focus:rounded-full focus:bg-primary focus:px-4 focus:py-2 focus:text-sm focus:font-semibold focus:text-primary-content" href="#main">Skip to main content</a>

  <!-- Clean Mobile Header -->
  <style id="mobile-header-compact" aria-hidden="true">
  :root {
    --mobile-header-height: 120px;
  }

  /* Make header visually compact while preserving touch targets and accessibility */
  .mc-header {
    padding-top: calc(env(safe-area-inset-top, 0px) + 8px);
    padding-bottom: 6px;
    padding-left: 12px;
    padding-right: 12px;
    display: flex;
    flex-direction: column;
    gap: 12px;
    border-bottom: 1px solid rgba(0,0,0,0.06);
    background: rgba(255,255,255,0.85);
    backdrop-filter: blur(6px);
    -webkit-backdrop-filter: blur(6px);
  }

  .mc-header-top {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    order: 0;
  }

  .mc-header-meta {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  /* Branding: very small */
  .mc-brand {
    display: flex;
    align-items: center;
    gap: 8px;
    min-width: 0;
  }
  .mc-brand .logo {
    width: 28px;
    height: 28px;
    border-radius: 6px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
    font-size: 0.95rem;
  }
  .mc-brand .title {
    font-size: 0.95rem;
    font-weight: 600;
    margin-left: 2px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: none; /* hide textual title on narrow screens; keeps brands minimal */
  }

  /* Status indicator is tiny and condensed */
  #mcStatus {
    width: 10px;
    height: 10px;
    border-radius: 9999px;
    display: inline-block;
    margin-right: 6px;
    vertical-align: middle;
    box-shadow: none;
  }
  #mcStatus.sync-inline {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    font-size: 0.75rem;
    padding: 0 6px;
    border-radius: 9999px;
    background: rgba(15,23,42,0.04);
  }
  /* keep the verbose status text accessible but visually hidden */
  #mcStatusText { position: absolute !important; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }

  /* Smaller circular buttons */
  .mc-btn {
    width: 36px;
    height: 36px;
    min-width: 36px;
    min-height: 36px;
    border-radius: 10px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0;
    font-size: 1.05rem;
  }
  .mc-btn.icon-only { padding: 0.125rem; }

  /* Overflow menu anchor spacing */
  .mc-actions { display: flex; gap: 6px; align-items: center; }

  /* Reduce hit area bloat visually but keep target size via padding if needed for a11y */
  .mc-header .mc-btn { padding: 0; }

  .mc-add-btn {
    display: inline-flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    padding: 0.55rem 0.85rem;
    border-radius: 12px;
    font-size: 0.8125rem;
    font-weight: 600;
    line-height: 1.1;
    background: rgba(255, 255, 255, 0.88);
    color: rgba(15, 23, 42, 0.92);
    border: 1px solid rgba(148, 163, 184, 0.25);
    box-shadow: 0 1px 2px rgba(15, 23, 42, 0.08);
    transition: background-color 0.15s ease, box-shadow 0.15s ease, transform 0.15s ease;
    white-space: nowrap;
    flex-shrink: 0;
  }

  .mc-add-btn:hover,
  .mc-add-btn:focus-visible {
    background: rgba(255, 255, 255, 0.95);
    box-shadow: 0 4px 12px rgba(15, 23, 42, 0.12);
    transform: translateY(-1px);
  }

  .mc-add-btn:focus-visible {
    outline: 2px solid rgba(59, 130, 246, 0.4);
    outline-offset: 2px;
  }

  .mc-add-btn__hint {
    font-size: 0.75rem;
    opacity: 0.7;
    font-weight: 500;
  }

  .dark .mc-add-btn {
    background: rgba(15, 23, 42, 0.7);
    color: rgba(226, 232, 240, 0.9);
    border-color: rgba(71, 85, 105, 0.45);
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.25);
  }

  .dark .mc-add-btn:hover,
  .dark .mc-add-btn:focus-visible {
    background: rgba(30, 41, 59, 0.8);
    box-shadow: 0 6px 14px rgba(15, 23, 42, 0.45);
  }

  /* On slightly larger phones show small text label next to logo (optional) */
  @media (min-width: 420px) {
    .mc-brand .title { display: inline; font-size: 0.95rem; }
  }
  </style>

  <header class="mc-header" role="banner" aria-label="Primary header">
    <div class="mc-header-top">
      <div class="mc-brand" aria-hidden="false">
        <a href="#" class="logo" title="Memory Cue">MC</a>
        <span class="title">Memory Cue</span>
      </div>

      <div class="mc-header-meta">
        <!-- status (visual tiny dot + accessible text) -->
        <div id="syncStatus" class="sync-inline" aria-hidden="false" data-state="offline" title="Sync status">
          <span id="mcStatus" class="sync-dot offline" role="status" aria-hidden="true"></span>
        </div>
        <span id="mcStatusText" class="sr-only">Offline</span>

        <div class="mc-actions" id="headerQuickActions" role="group" aria-label="Header actions">
          <button type="button" class="mc-add-btn" data-open-add-task>
            <span>New reminder</span>
            <span class="mc-add-btn__hint" aria-hidden="true">Ôºã</span>
          </button>
          <!-- Overflow / more -->
          <div style="position:relative;">
            <button id="overflowMenuBtn" type="button" class="mc-btn btn btn-ghost icon-only" aria-label="More options" aria-haspopup="true" aria-controls="overflowMenu" aria-expanded="false">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" aria-hidden="true" focusable="false"><circle cx="12" cy="5" r="1.5" /><circle cx="12" cy="12" r="1.5" /><circle cx="12" cy="19" r="1.5" /></svg>
            </button>

            <div id="overflowMenu" class="menu-card hidden absolute right-0 mt-2 w-44 rounded-xl shadow-lg bg-base-100 border" role="menu" aria-hidden="true">
              <ul class="py-2 text-sm" role="none"></ul>
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>

  <div
    id="mobile-drawer-scrim"
    class="fixed inset-0 z-30 bg-neutral-900/40 opacity-0 transition-opacity duration-200 pointer-events-none"
  ></div>
  <aside
    id="mobile-drawer"
    class="fixed inset-y-0 left-0 z-40 flex w-72 max-w-full -translate-x-full transform flex-col border-r border-neutral-200 bg-white/90 px-4 pb-6 pt-6 font-medium text-neutral-900 shadow-xl transition-transform duration-200 ease-out backdrop-blur dark:border-neutral-800 dark:bg-neutral-900/85 dark:text-neutral-100"
    inert
    tabindex="-1"
    style="padding-top: calc(env(safe-area-inset-top, 0px) + 1rem)"
  >
    <div class="mb-6 flex items-center justify-between">
           <button
        type="button"
        class="rounded-xl p-2 text-neutral-500 hover:bg-neutral-100 hover:text-neutral-900 dark:text-neutral-400 dark:hover:bg-neutral-800"
        aria-label="Close menu"
        data-close-drawer
      >
        <svg viewBox="0 0 24 24" class="size-5" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M6 6l12 12M6 18 18 6" />
        </svg>
      </button>
    </div>
    
    </div>
  </aside>

  <script>
    (function () {
      const drawerBtn = document.getElementById('btn-open-drawer');
      const drawer = document.getElementById('mobile-drawer');
      const scrim = document.getElementById('mobile-drawer-scrim');
      const scrollTopBtn = document.getElementById('btn-scroll-top');
      const quickAddBtn = document.getElementById('addReminderBtn');
      const searchBtn = document.getElementById('btn-search');
      const themeBtn = document.getElementById('btn-theme');
      const drawerSyncStatus = document.getElementById('drawerSyncStatus');
      const headerSyncStatus = document.getElementById('mcStatusText');
      const headerSyncDot = document.getElementById('mcStatus');
      const drawerSyncDot = drawer?.querySelector('.sync-dot');

      const toggleClass = (el, className, force) => {
        if (!el) return;
        if (typeof force === 'boolean') {
          el.classList.toggle(className, force);
        } else {
          el.classList.toggle(className);
        }
      };

      const setDrawerState = (open) => {
        if (!drawer) return;
        const isOpen = drawer.classList.contains('translate-x-0');
        const nextState = typeof open === 'boolean' ? open : !isOpen;
        if (nextState === isOpen) return;

        if (nextState) {
          drawer.inert = false;
          drawer.classList.add('translate-x-0');
          drawerBtn?.setAttribute('aria-expanded', 'true');
          if (scrim) {
            scrim.classList.remove('pointer-events-none');
            scrim.classList.remove('opacity-0');
            scrim.classList.add('opacity-100');
          }
          document.body.classList.add('overflow-hidden');
          if (!drawer.hasAttribute('data-focus-bound')) {
            drawer.setAttribute('data-focus-bound', 'true');
            drawer.focus({ preventScroll: true });
          } else {
            try {
              drawer.focus({ preventScroll: true });
            } catch {
              drawer.focus();
            }
          }
        } else {
          drawer.classList.remove('translate-x-0');
          drawerBtn?.setAttribute('aria-expanded', 'false');
          if (scrim) {
            scrim.classList.add('opacity-0');
            scrim.classList.add('pointer-events-none');
            scrim.classList.remove('opacity-100');
          }
          document.body.classList.remove('overflow-hidden');
          drawer.removeAttribute('data-focus-bound');
          if (drawerBtn instanceof HTMLElement) {
            try {
              drawerBtn.focus({ preventScroll: true });
            } catch {
              drawerBtn.focus();
            }
          }
          drawer.inert = true;
        }
      };

      drawerBtn?.addEventListener('click', () => setDrawerState());
      scrim?.addEventListener('click', () => setDrawerState(false));
      drawer?.addEventListener('click', (event) => {
        if (event.target instanceof Element && event.target.closest('[data-close-drawer]')) {
          setDrawerState(false);
        }
      });
      document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          setDrawerState(false);
        }
      });

      scrollTopBtn?.addEventListener('click', () => {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      });

      quickAddBtn?.addEventListener('click', () => {
        const tryCall = (fn) => {
          try {
            return typeof fn === 'function' ? fn() : undefined;
          } catch (error) {
            console.warn('Quick add hook failed', error);
            return undefined;
          }
        };
        const result =
          tryCall(window.quickAdd) ??
          tryCall(window.openAddModal) ??
          (function () {
            const fallback = document.querySelector('[data-open-add-task]') || document.getElementById('addReminderBtn');
            if (fallback instanceof HTMLElement) {
              fallback.click();
              return true;
            }
            return document.getElementById('quickAddInput')?.focus();
          })();
        return result;
      });

      searchBtn?.addEventListener('click', () => {
        const el = document.getElementById('search') || document.querySelector('input[type="search"]');
        if (el instanceof HTMLElement) {
          el.scrollIntoView({ block: 'center', behavior: 'smooth' });
          try {
            el.focus({ preventScroll: true });
          } catch {
            el.focus();
          }
        }
      });

      const THEME_STORAGE_KEY = 'theme';
      const root = document.documentElement;

      const applyTheme = (nextTheme) => {
        const next = nextTheme === 'dark' ? 'dark' : 'light';
        root.setAttribute('data-theme', next);
        root.classList.toggle('dark', next === 'dark');
        try {
          localStorage.setItem(THEME_STORAGE_KEY, next);
        } catch {
          /* storage might be unavailable */
        }
        toggleClass(document.getElementById('icon-sun'), 'hidden', next === 'dark');
        toggleClass(document.getElementById('icon-moon'), 'hidden', next !== 'dark');
      };

      const toggleTheme = () => {
        const current = root.getAttribute('data-theme') === 'dark' ? 'dark' : 'light';
        applyTheme(current === 'dark' ? 'light' : 'dark');
      };

      themeBtn?.addEventListener('click', toggleTheme);

      window.__mcApplyTheme = applyTheme;
      window.__mcToggleTheme = toggleTheme;

      (function initTheme() {
        let saved = null;
        try {
          saved = localStorage.getItem(THEME_STORAGE_KEY);
        } catch {
          saved = null;
        }
        if (!saved) {
          saved = root.getAttribute('data-theme');
        }
        if (saved) {
          applyTheme(saved);
        }
      })();

      document.addEventListener('cue:sync-status', (event) => {
        const detail = event?.detail;
        if (!detail) return;
        if (typeof detail.message === 'string' && drawerSyncStatus) {
          drawerSyncStatus.textContent = detail.message;
        }
        if (typeof detail.state === 'string' && drawerSyncDot) {
          const isOnline = detail.state !== 'offline' && detail.state !== 'error';
          drawerSyncDot.classList.toggle('online', isOnline);
          drawerSyncDot.classList.toggle('offline', !isOnline);
        }
      });

      if (typeof MutationObserver === 'function') {
        const syncStatusObserver = new MutationObserver(() => {
          if (headerSyncStatus && drawerSyncStatus) {
            drawerSyncStatus.textContent = headerSyncStatus.textContent || '';
          }
        });

        if (headerSyncStatus) {
          syncStatusObserver.observe(headerSyncStatus, { childList: true });
        }

        const syncDotObserver = new MutationObserver(() => {
          if (headerSyncDot && drawerSyncDot) {
            const isOnline = headerSyncDot.classList.contains('online');
            drawerSyncDot.classList.toggle('online', isOnline);
            drawerSyncDot.classList.toggle('offline', !isOnline);
          }
        });

        if (headerSyncDot) {
          syncDotObserver.observe(headerSyncDot, { attributes: true, attributeFilter: ['class'] });
        }
      }

      if (headerSyncStatus && drawerSyncStatus) {
        drawerSyncStatus.textContent = headerSyncStatus.textContent || drawerSyncStatus.textContent || '';
      }
      if (headerSyncDot && drawerSyncDot) {
        const isOnline = headerSyncDot.classList.contains('online');
        drawerSyncDot.classList.toggle('online', isOnline);
        drawerSyncDot.classList.toggle('offline', !isOnline);
      }
    })();
  </script>

  <main id="main" class="max-w-md mx-auto px-4 pt-0 pb-4" tabindex="-1" data-active-view="reminders">
    <!-- BEGIN GPT CHANGE: create form moved to bottom sheet -->
    <!-- END GPT CHANGE -->
    <!-- BEGIN GPT CHANGE: reminders view -->
    <section data-view="reminders" id="view-reminders" class="view-panel">
      <!-- Quick add form -->
      <!-- Compact Quick Add -->
      <section id="quickAddBar" class="mb-4" aria-label="Quick add reminder">
        <div class="flex items-center gap-2 p-3 bg-base-100/80 backdrop-blur-sm rounded-xl border border-base-200/50">
          <input id="quickAddInput"
                 type="text"
                 class="flex-1 px-3 py-2 text-sm bg-transparent border-0 outline-none placeholder:text-base-content/50"
                 placeholder="Add reminder..."
                 aria-label="Quick add reminder"
                 autocomplete="off" />

          <button id="quickAddVoiceBtn"
                  type="button"
                  class="w-8 h-8 flex items-center justify-center rounded-lg text-base-content/60 hover:text-base-content hover:bg-base-200/50 transition-colors"
                  title="Dictate reminder"
                  aria-label="Dictate reminder"
                  aria-pressed="false">
            <span class="text-base">üéôÔ∏è</span>
          </button>

          <button id="quickAddSubmit"
                  class="px-3 py-1.5 text-sm font-medium text-white bg-primary rounded-lg hover:bg-primary/90 active:scale-95 transition-all"
                  type="button"
                  aria-label="Add reminder">Add</button>
        </div>
      </section>

      <section id="reminderListSection" class="bg-base-100/60 backdrop-blur-sm rounded-xl border border-base-200/30 relative">
        <button id="viewToggle" class="view-toggle btn btn-ghost btn-xs" type="button">
          <span class="grid-icon">‚äû</span>
          <span class="list-icon hidden">‚ò∞</span>
        </button>
        <div class="p-4" id="remindersWrapper">
          <div id="emptyState" class="hidden text-center text-base-content/60 py-8"></div>
          <ul id="reminderList" class="grid grid-cols-1 sm:grid-cols-2 gap-3"></ul>
          <p class="text-xs text-base-content/50 mt-4 pt-3 border-t border-base-200/30">Total reminders: <span id="totalCount">0</span></p>
        </div>
      </section>
    </section>
    <!-- END GPT CHANGE -->
    <!-- BEGIN GPT CHANGE: notebook view -->
    <section data-view="notebook" id="view-notebook" class="view-panel hidden">
      <section class="card bg-base-100 border">
        <div class="card-body gap-3 compact">
          <div class="flex items-center justify-between gap-2">
            <h2 class="card-title text-base">Scratch Notes</h2>
            <button type="button" class="btn btn-ghost btn-xs" data-jump-view="reminders">Back to reminders</button>
          </div>
          <div
            id="notesToolbar"
            class="flex flex-wrap gap-2"
            role="toolbar"
            aria-label="Scratch notes formatting options"
            aria-controls="notes"
          >
            <button type="button" class="btn btn-xs" data-action="bullets">‚Ä¢ Bullets</button>
            <button type="button" class="btn btn-xs" data-action="numbers">1. Numbers</button>
            <button
              type="button"
              class="btn btn-xs"
              data-action="columns"
              aria-pressed="false"
            >
              Columns
            </button>
          </div>
          <div
            id="notes"
            class="notes-editor"
            contenteditable="true"
            role="textbox"
            aria-multiline="true"
            spellcheck="true"
            data-placeholder="Quick personal notes"
          ></div>
          <div class="flex gap-2">
            <button id="saveNotes" class="btn btn-outline flex-1" type="button">Save notes</button>
            <button id="loadNotes" class="btn btn-outline flex-1" type="button">Load notes</button>
          </div>
        </div>
      </section>

    </section>
    <!-- END GPT CHANGE -->
</main>

  <nav class="btm-nav fixed bottom-0 left-0 right-0 bg-base-100 border-t" aria-label="Primary navigation">
    <button type="button" aria-current="page" class="active">
      <span class="btm-nav-label">Reminders</span>
    </button>
    <button type="button">
      <span class="btm-nav-label">Notebook</span>
    </button>
  </nav>
  <!-- build-marker: mobile.html / runs mobile.js / EXPECTED LIVE -->
  <!-- When deployed, this should appear in View Source with today‚Äôs date. -->

  <script>
    window.memoryCueEmptyStateCtaClasses = 'btn btn-primary btn-sm w-full sm:w-auto';
    window.memoryCueMountEmptyState = function mountCompactEmptyState(target, config) {
      if (!(target instanceof HTMLElement)) {
        return;
      }

      const { title, description, action } = config || {};
      const wrapper = document.createElement('div');
      wrapper.className = 'empty-state-compact';
      wrapper.setAttribute('role', 'presentation');

      if (title) {
        const heading = document.createElement('h3');
        heading.textContent = title;
        wrapper.appendChild(heading);
      }

      if (description) {
        const paragraph = document.createElement('p');
        paragraph.textContent = description;
        wrapper.appendChild(paragraph);
      }

      if (action) {
        const actions = document.createElement('div');
        actions.className = 'empty-state-actions';
        actions.innerHTML = action;
        wrapper.appendChild(actions);
      }

      target.replaceChildren(wrapper);
    };

    const viewToggle = document.getElementById('viewToggle');
    const reminderList = document.getElementById('reminderList');

    if (viewToggle && reminderList) {
      const setCompactMode = (compact) => {
        document.querySelectorAll('.task-item').forEach((item) => {
          if (compact) {
            item.setAttribute('data-compact', 'true');
          } else {
            item.removeAttribute('data-compact');
          }
        });
      };

      const updateToggleIcons = (isGridView) => {
        const gridIcon = viewToggle.querySelector('.grid-icon');
        const listIcon = viewToggle.querySelector('.list-icon');
        if (!gridIcon || !listIcon) return;
        if (isGridView) {
          gridIcon.classList.add('hidden');
          listIcon.classList.remove('hidden');
        } else {
          gridIcon.classList.remove('hidden');
          listIcon.classList.add('hidden');
        }
      };

      const ensureInitialState = () => {
        let isGridView = reminderList.classList.contains('grid-cols-2');

        if (!isGridView && !reminderList.classList.contains('space-y-3')) {
          reminderList.classList.add('grid-cols-2');
          isGridView = true;
        }

        updateToggleIcons(isGridView);
        setCompactMode(isGridView);
      };

      viewToggle.addEventListener('click', function () {
        const isGridView = reminderList.classList.contains('grid-cols-2');

        if (isGridView) {
          reminderList.classList.remove('grid-cols-2');
          reminderList.classList.add('space-y-3');
          updateToggleIcons(false);
          setCompactMode(false);
        } else {
          reminderList.classList.add('grid-cols-2');
          reminderList.classList.remove('space-y-3');
          updateToggleIcons(true);
          setCompactMode(true);
        }
      });

      ensureInitialState();
    }
  </script>
  <!-- Load the mobile app bundle (build will rewrite to hashed path) -->
  <script type="module" src="./assets/mobile-5UVXCT36.js?v=2025-10-29-1"></script>
  <script type="module" src="./assets/mobile-theme-toggle-KTZLCBCC.js"></script>
  <!-- BEGIN GPT CHANGE: bottom sheet for Create Reminder -->
  <div id="create-sheet" role="dialog" aria-modal="true" aria-labelledby="createSheetTitle" class="sheet hidden" tabindex="-1" data-add-task-dialog>
    <div class="sheet-panel bg-base-100 border-t border-base-200" data-dialog-content>
      <header class="sheet-header">
        <h2 id="createSheetTitle">Create Reminder</h2>
        <div class="sheet-header-actions">
          <button
            id="voiceBtn"
            type="button"
            class="btn btn-circle btn-ghost"
            aria-label="Start voice input"
            aria-pressed="false"
            title="Fill reminder using your voice"
          >
            <span aria-hidden="true">üéôÔ∏è</span>
            <span class="sr-only">Start voice input</span>
          </button>
          <button type="button" id="closeCreateSheet" aria-label="Close">‚úï</button>
        </div>
      </header>
      <form id="createReminderForm" class="inputs-compact">
        <div class="card-body gap-4 compact">
          <label class="form-control w-full">
            <div class="label"><span class="label-text">Reminder</span></div>
            <input
              id="reminderText"
              type="text"
              placeholder=""
              class="input input-bordered w-full"
              autocomplete="off"
            />
          </label>

          <label class="form-control w-full">
            <div class="label"><span class="label-text">Notes</span></div>
            <textarea
              id="reminderDetails"
              class="textarea textarea-bordered"
              rows="3"
              placeholder="Optional context for the reminder"
            ></textarea>
          </label>

          <div class="grid grid-cols-2 gap-3">
            <label class="form-control">
              <div class="label"><span class="label-text">Date</span></div>
              <input id="reminderDate" type="date" class="input input-bordered" />
            </label>
            <label class="form-control">
              <div class="label"><span class="label-text">Time</span></div>
              <input id="reminderTime" type="time" class="input input-bordered" />
            </label>
          </div>

          <div id="dateFeedback" class="text-xs text-info"></div>

          <div class="grid grid-cols-2 gap-3">
            <div class="form-control">
              <div class="label"><span class="label-text">Priority</span></div>
              <select id="priority" class="select select-bordered hidden" aria-hidden="true" tabindex="-1">
                <option value="High">High</option>
                <option value="Medium" selected>Medium</option>
                <option value="Low">Low</option>
              </select>
              <!-- BEGIN GPT CHANGE: priority chips -->
              <fieldset id="priorityChips" aria-label="Priority" class="chip-row">
                <label><input type="radio" name="priority" value="High"> High</label>
                <label><input type="radio" name="priority" value="Medium" checked> Medium</label>
                <label><input type="radio" name="priority" value="Low"> Low</label>
              </fieldset>
              <!-- END GPT CHANGE: priority chips -->
            </div>
            <label class="form-control">
              <div class="label"><span class="label-text">Category</span></div>
              <input
                id="category"
                class="input input-bordered"
                list="categorySuggestions"
                placeholder="General"
                value="General"
              />
              <datalist id="categorySuggestions">
                <option value="General"></option>
                <option value="General Appointments"></option>
                <option value="Home &amp; Personal"></option>
                <option value="School ‚Äì Appointments/Meetings"></option>
                <option value="School ‚Äì Communication &amp; Families"></option>
                <option value="School ‚Äì Excursions &amp; Events"></option>
                <option value="School ‚Äì Grading &amp; Assessment"></option>
                <option value="School ‚Äì Prep &amp; Resources"></option>
                <option value="School ‚Äì To-Do"></option>
                <option value="Wellbeing &amp; Support"></option>
              </datalist>
            </label>
          </div>

          <div class="flex flex-wrap items-center gap-3">
            <button id="notifBtn" class="btn btn-ghost" type="button">Enable notifications</button>
          </div>

          <div class="flex flex-col gap-2">
            <button
              id="sheetVoiceBtn"
              class="btn btn-outline justify-center"
              type="button"
              aria-pressed="false"
              aria-label="Dictate reminder"
            >
              üé§ Voice input
            </button>
            <p
              id="sheetVoiceStatus"
              class="text-xs text-base-content/60"
              role="status"
              aria-live="polite"
              hidden
            >
              Tap the microphone to start speaking.
            </p>
          </div>

          <div class="card-actions justify-stretch">
            <button id="saveReminder" class="btn btn-primary w-full" type="button">Save Reminder</button>
            <button id="cancelEditBtn" class="btn btn-outline w-full hidden" type="button">Cancel</button>
          </div>
          <p id="statusMessage" class="text-sm text-base-content/70" role="status" aria-live="polite"></p>
        </div>
      </form>
    </div>
    <div class="sheet-backdrop backdrop" data-close></div>
  </div>
  <!-- END GPT CHANGE: bottom sheet for Create Reminder -->

  <!-- BEGIN GPT CHANGE: settings modal -->
  <div id="settingsModal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle" class="hidden">
    <div class="modal-panel">
      <header class="modal-header">
        <h2 id="settingsTitle">Settings</h2>
        <button type="button" id="closeSettings" aria-label="Close">‚úï</button>
      </header>
      <div class="card bg-base-100 border-0">
        <div class="card-body gap-4 compact">
          <h2 class="card-title text-base">Sync Settings</h2>
          <p class="text-sm text-base-content/70">Configure your Google Apps Script endpoint to sync reminders to Calendar.</p>
          <label class="form-control">
            <div class="label"><span class="label-text">Apps Script URL</span></div>
            <input id="syncUrl" type="url" class="input input-bordered" placeholder="https://script.google.com/macros/s/.../exec" />
          </label>
          <div class="card-actions flex-col gap-2">
            <div class="flex gap-2 w-full">
              <button id="saveSyncSettings" class="btn btn-outline flex-1" type="button">Save Settings</button>
              <button id="testSync" class="btn btn-outline flex-1" type="button">Test Connection</button>
            </div>
            <button id="syncAll" class="btn btn-primary w-full" type="button">Sync All</button>
          </div>
          <p class="text-xs text-base-content/60">Tip: In Google Apps Script choose <strong>Deploy ‚Üí Web app</strong>, execute as yourself and allow access to anyone with the link.</p>
        </div>
      </div>
    </div>
    <div class="modal-backdrop" data-close></div>
  </div>
  <!-- END GPT CHANGE: settings modal -->

  <script id="mobile-enhancements">
    document.querySelectorAll('[data-close]').forEach((btn) => {
      btn.addEventListener('click', (event) => {
        const trigger = event.target;
        const dialog = trigger?.closest?.('.sheet, .modal');
        if (dialog) {
          dialog.classList.add('hidden');
        }
      });
    });

    // Enhanced add button functionality
    (function () {
      const addBtn = document.getElementById('addReminderBtn');
      const addOptionsFab = document.getElementById('addOptionsFab');
      if (!addBtn || !addOptionsFab) return;

      let suppressVoiceTrigger = false;

      addBtn.addEventListener('click', function () {
        const isExpanded = this.getAttribute('aria-expanded') === 'true';
        this.setAttribute('aria-expanded', String(!isExpanded));
        addOptionsFab.classList.toggle('active');

        if (!isExpanded) {
          this.style.transform = 'rotate(45deg)';
        } else {
          this.style.transform = 'rotate(0deg)';
        }
      });

      document.addEventListener('click', (event) => {
        if (!event.target.closest('.add-button-container')) {
          addOptionsFab.classList.remove('active');
          addBtn.setAttribute('aria-expanded', 'false');
          addBtn.style.transform = 'rotate(0deg)';
        }
      });

      document.querySelectorAll('.add-option-item').forEach((item) => {
        item.addEventListener('click', function () {
          const addType = this.dataset.addType;

          addOptionsFab.classList.remove('active');
          addBtn.setAttribute('aria-expanded', 'false');
          addBtn.style.transform = 'rotate(0deg)';

          switch (addType) {
            case 'reminder': {
              const quickAddInput = document.getElementById('quickAddInput');
              quickAddInput?.focus();
              break;
            }
            case 'voice': {
              if (suppressVoiceTrigger) {
                suppressVoiceTrigger = false;
                break;
              }
              const voiceOption = document.getElementById('voiceAddBtn');
              if (voiceOption) {
                suppressVoiceTrigger = true;
                voiceOption.click();
                const resetTrigger = () => {
                  suppressVoiceTrigger = false;
                };
                if (typeof queueMicrotask === 'function') {
                  queueMicrotask(resetTrigger);
                } else {
                  setTimeout(resetTrigger, 0);
                }
              }
              break;
            }
            case 'note': {
              // Add note creation logic here
              break;
            }
            default:
              break;
          }
        });
      });
    })();

    (function () {
      const views = {
        reminders: document.querySelector('[data-view="reminders"]'),
        notebook: document.querySelector('[data-view="notebook"]'),
      };
      const nav = document.querySelector('.btm-nav');
      if (!nav) return;

      const buttons = Array.from(nav.querySelectorAll('button')).slice(0, 2);
      const order = ['reminders', 'notebook'];

      if (!buttons.length || order.some((key) => !views[key])) {
        return;
      }

      const reduceMotion = typeof window !== 'undefined' && typeof window.matchMedia === 'function'
        ? window.matchMedia('(prefers-reduced-motion: reduce)')
        : null;

      let activeView = order[0];

      const setActiveView = (target) => {
        if (!order.includes(target)) return;

        order.forEach((key, index) => {
          const view = views[key];
          const button = buttons[index];
          const isActive = key === target;

          if (view) {
            view.classList.toggle('hidden', !isActive);
            view.setAttribute('aria-hidden', String(!isActive));
          }

          if (button) {
            button.setAttribute('aria-current', isActive ? 'page' : 'false');
            button.classList.toggle('active', Boolean(isActive));
          }
        });

        activeView = target;

        const skipLink =
          document.querySelector('.skip-link') ||
          document.querySelector('a[href$="#main"]');
        const main = document.getElementById('main') || document.querySelector('main');
        if (main) {
          main.setAttribute('data-active-view', target);
        }
        if (skipLink && main) {
          const behaviour = reduceMotion?.matches ? 'auto' : 'smooth';
          try {
            window.scrollTo({ top: 0, behavior: behaviour });
          } catch {
            window.scrollTo(0, 0);
          }
        }
      };

      buttons.forEach((button, index) => {
        button.addEventListener('click', () => {
          setActiveView(order[index]);
        });
      });

      document.querySelectorAll('[data-jump-view]').forEach((control) => {
        control.addEventListener('click', () => {
          const target = control.getAttribute('data-jump-view');
          if (target) {
            setActiveView(target);
          }
        });
      });

      document.querySelectorAll('[data-scroll-target]').forEach((control) => {
        control.addEventListener('click', () => {
          const targetId = control.getAttribute('data-scroll-target');
          if (!targetId) return;
          const el = document.getElementById(targetId);
          if (!el) return;
          try {
            el.scrollIntoView({ behavior: 'smooth', block: 'start' });
          } catch {
            el.scrollIntoView(true);
          }
        });
      });

      const main = document.getElementById('main') || document.querySelector('main');
      if (main) {
        const SWIPE_MIN_DISTANCE = 60;
        const SWIPE_MAX_OFF_AXIS = 80;
        const SWIPE_MAX_DURATION = 600;
        let startX = 0;
        let startY = 0;
        let startTime = 0;
        let tracking = false;

        const resetSwipeTracking = () => {
          tracking = false;
          startX = 0;
          startY = 0;
          startTime = 0;
        };

        const isInteractiveTarget = (target) => {
          if (!(target instanceof Element)) return false;
          return Boolean(
            target.closest(
              '[data-no-swipe], input, textarea, select, button, [role="button"], [role="textbox"], [contenteditable="true"], [contenteditable=""]'
            )
          );
        };

        main.addEventListener(
          'touchstart',
          (event) => {
            if (event.touches.length !== 1) {
              resetSwipeTracking();
              return;
            }

            const target = event.target;
            if (target instanceof Element && isInteractiveTarget(target)) {
              resetSwipeTracking();
              return;
            }

            const touch = event.touches[0];
            startX = touch.clientX;
            startY = touch.clientY;
            startTime = event.timeStamp || Date.now();
            tracking = true;
          },
          { passive: true }
        );

        main.addEventListener(
          'touchmove',
          (event) => {
            if (!tracking) return;
            if (event.touches.length !== 1) {
              resetSwipeTracking();
            }
          },
          { passive: true }
        );

        main.addEventListener(
          'touchend',
          (event) => {
            if (!tracking) return;
            tracking = false;

            if (!event.changedTouches || !event.changedTouches.length) {
              resetSwipeTracking();
              return;
            }

            const touch = event.changedTouches[0];
            const deltaX = touch.clientX - startX;
            const deltaY = touch.clientY - startY;
            const duration = (event.timeStamp || Date.now()) - startTime;
            resetSwipeTracking();

            if (Math.abs(deltaX) < SWIPE_MIN_DISTANCE) return;
            if (Math.abs(deltaY) > SWIPE_MAX_OFF_AXIS) return;
            if (Math.abs(deltaX) <= Math.abs(deltaY)) return;
            if (duration > SWIPE_MAX_DURATION) return;

            const currentIndex = order.indexOf(activeView);
            if (currentIndex === -1) return;

            if (deltaX < 0 && currentIndex < order.length - 1) {
              setActiveView(order[currentIndex + 1]);
            } else if (deltaX > 0 && currentIndex > 0) {
              setActiveView(order[currentIndex - 1]);
            }
          },
          { passive: true }
        );

        main.addEventListener('touchcancel', resetSwipeTracking, { passive: true });
      }

      setActiveView('reminders');
    })();

    (function () {
      const list = document.getElementById('reminderList');
      if (!list) return;

      const allChildren = Array.from(list.children);
      if (allChildren.length <= 30) return;

      const PAGE_SIZE = 20;
      list.innerHTML = '';
      let index = 0;

      const appendPage = () => {
        const slice = allChildren.slice(index, index + PAGE_SIZE);
        slice.forEach((node) => list.appendChild(node));
        index += slice.length;
      };

      appendPage();

      const sentinel = document.createElement('div');
      sentinel.id = 'listSentinel';
      list.appendChild(sentinel);

      const observer = new IntersectionObserver((entries) => {
        if (entries.some((entry) => entry.isIntersecting) && index < allChildren.length) {
          appendPage();
          if (index >= allChildren.length) {
            observer.disconnect();
          }
        }
      });

      observer.observe(sentinel);
    })();

    (function () {
      const openBtns = Array.from(
        document.querySelectorAll('[data-open="settings"]'),
      ).filter((btn) => btn instanceof HTMLElement);
      const modal = document.getElementById('settingsModal');
      const closeBtn = document.getElementById('closeSettings');
      if (!openBtns.length || !modal || !closeBtn) return;

      const open = () => {
        modal.classList.remove('hidden');
      };

      const close = () => {
        modal.classList.add('hidden');
      };

      openBtns.forEach((btn) => btn.addEventListener('click', open));
      closeBtn.addEventListener('click', close);
      modal.addEventListener('click', (event) => {
        if (event.target instanceof HTMLElement && event.target.matches('[data-close]')) {
          close();
        }
      });
      modal.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          close();
        }
      });
    })();

    (function () {
      const statusContainer = document.getElementById('syncStatus');
      const statusDotEl = document.getElementById('mcStatus');
      const statusTextEl = document.getElementById('mcStatusText');
      if (!statusTextEl) return;

      const syncUrlInput = document.getElementById('syncUrl');
      const saveSettingsBtn = document.getElementById('saveSyncSettings');
      const testSyncBtn = document.getElementById('testSync');
      const syncAllBtn = document.getElementById('syncAll');
      const STORAGE_KEY = 'syncUrl';
      const ACTIVE_CLASSES = ['online', 'offline', 'error'];
      const DOT_CLASSES = ['online', 'offline'];

      let currentState = null;

      const DEFAULT_MESSAGES = {
        checking: 'Checking connection‚Ä¶',
        syncing: 'Syncing your latest changes‚Ä¶',
        online: 'Connected. Changes sync automatically.',
        offline: "You're offline. Changes are saved on this device until you reconnect.",
        error: "We couldn't sync right now. We'll retry soon.",
        info: '',
      };

      const DISPLAY_MESSAGES = {
        checking: 'Checking‚Ä¶',
        syncing: 'Syncing‚Ä¶',
        online: 'Synced. Auto-save on.',
        offline: 'Offline. Saving locally.',
        error: 'Sync issue. Retrying.',
        info: '',
      };

      const applyDotState = (state) => {
        if (!statusDotEl) return;
        DOT_CLASSES.forEach((cls) => statusDotEl.classList.remove(cls));
        const isOnline = state !== 'offline' && state !== 'error';
        statusDotEl.classList.add(isOnline ? 'online' : 'offline');
        statusDotEl.setAttribute('aria-label', isOnline ? 'Online' : 'Offline');
      };

      const setStatus = (state, message) => {
        currentState = state;
        ACTIVE_CLASSES.forEach((cls) => statusTextEl.classList.remove(cls));
        if (statusContainer) {
          ACTIVE_CLASSES.forEach((cls) => statusContainer.classList.remove(cls));
        }

        if (statusContainer) {
          statusContainer.setAttribute('data-state', state);
        }

        if (state === 'online') {
          statusTextEl.classList.add('online');
          if (statusContainer) statusContainer.classList.add('online');
        } else if (state === 'error') {
          statusTextEl.classList.add('error');
          if (statusContainer) statusContainer.classList.add('error');
        } else {
          statusTextEl.classList.add('offline');
          if (statusContainer) statusContainer.classList.add('offline');
        }

        const fullText =
          typeof message === 'string' && message.trim()
            ? message.trim()
            : DEFAULT_MESSAGES[state] || '';

        const displayText =
          typeof message === 'string' && message.trim()
            ? message.trim()
            : DISPLAY_MESSAGES[state] || fullText;

        const srText = fullText || displayText || '';
        statusTextEl.dataset.state = state;
        statusTextEl.textContent = srText;

        if (srText) {
          statusTextEl.setAttribute('title', srText);
          statusTextEl.setAttribute('aria-label', srText);
        } else {
          statusTextEl.removeAttribute('title');
          statusTextEl.removeAttribute('aria-label');
        }

        applyDotState(state);
      };

      const updateOnlineState = () => {
        if (currentState === 'syncing') return;
        if (navigator.onLine) {
          if (currentState !== 'online') setStatus('online');
        } else {
          setStatus('offline');
        }
      };

      const persistUrl = (value) => {
        if (typeof localStorage === 'undefined') return;
        if (value) {
          localStorage.setItem(STORAGE_KEY, value);
        } else {
          localStorage.removeItem(STORAGE_KEY);
        }
      };

      const getStoredUrl = () => {
        if (typeof localStorage === 'undefined') return '';
        try {
          return localStorage.getItem(STORAGE_KEY) || '';
        } catch {
          return '';
        }
      };

      const normaliseReminder = (raw) => {
        if (!raw || typeof raw !== 'object') return null;
        const id = raw.id || raw.uid || raw.key || raw.slug || raw.uuid;
        let title = typeof raw.title === 'string' ? raw.title.trim() : '';
        if (!title && typeof raw.name === 'string') {
          title = raw.name.trim();
        }
        if (!title) return null;

        const dueIso = typeof raw.dueIso === 'string' && raw.dueIso
          ? raw.dueIso
          : (typeof raw.due === 'string' ? raw.due : null);

        const priority = typeof raw.priority === 'string' && raw.priority.trim()
          ? raw.priority.trim()
          : (raw.level || raw.importance || 'Medium');

        const category = typeof raw.category === 'string' && raw.category.trim()
          ? raw.category.trim()
          : (raw.group || raw.bucket || 'General');

        const done = typeof raw.done === 'boolean'
          ? raw.done
          : Boolean(raw.completed || raw.isDone || raw.status === 'done');

        const ensuredId = id || (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function'
          ? crypto.randomUUID()
          : `${Date.now()}-${Math.random()}`);

        return {
          id: ensuredId,
          title,
          dueIso: dueIso && dueIso.trim() ? dueIso.trim() : null,
          priority,
          category,
          done,
        };
      };

      const collectFromDom = () => {
        const elements = Array.from(document.querySelectorAll('[data-reminder]'));
        if (!elements.length) return [];

        return elements
          .map((el) => {
            const dataset = el.dataset || {};
            let raw = null;

            if (dataset.reminder) {
              try {
                const parsed = JSON.parse(dataset.reminder);
                if (parsed && typeof parsed === 'object') {
                  raw = parsed;
                }
              } catch {
                raw = null;
              }
            }

            const candidate = raw || {
              id: dataset.id || dataset.reminderId || el.getAttribute('data-id') || null,
              title: dataset.title || dataset.reminderTitle || '',
              dueIso: dataset.due || dataset.reminderDue || el.getAttribute('data-due') || null,
              priority: dataset.priority || dataset.reminderPriority || el.getAttribute('data-priority') || '',
              category: dataset.category || dataset.reminderCategory || el.getAttribute('data-category') || '',
              done: dataset.done === 'true' || dataset.reminderDone === 'true' || el.getAttribute('data-done') === 'true',
            };

            if (!candidate.title) {
              const titleEl = el.querySelector('[data-reminder-title], [data-title], h3, h4, strong');
              if (titleEl) {
                candidate.title = titleEl.textContent.trim();
              }
            }

            if (!candidate.dueIso) {
              const dueEl = el.querySelector('[data-due], time');
              if (dueEl) {
                const attr = dueEl.getAttribute('datetime') || dueEl.getAttribute('data-due');
                candidate.dueIso = attr || dueEl.textContent.trim();
              }
            }

            return normaliseReminder(candidate);
          })
          .filter(Boolean);
      };

      const collectFromStorage = () => {
        if (typeof localStorage === 'undefined') return [];
        const reminders = [];
        const triedKeys = new Set();
        const preferredKeys = [
          'memoryCue.reminders.v1',
          'memoryCue.reminders',
          'memoryCueMobile.reminders',
          'memoryCue.reminders.cache',
          'reminders',
        ];

        preferredKeys.forEach((key) => {
          if (triedKeys.has(key)) return;
          triedKeys.add(key);
          try {
            const value = localStorage.getItem(key);
            if (!value) return;
            const parsed = JSON.parse(value);
            if (Array.isArray(parsed)) {
              parsed.forEach((item) => reminders.push(item));
            } else if (parsed && typeof parsed === 'object') {
              if (Array.isArray(parsed.items)) parsed.items.forEach((item) => reminders.push(item));
              if (Array.isArray(parsed.reminders)) parsed.reminders.forEach((item) => reminders.push(item));
            }
          } catch {
            // ignore invalid storage entries
          }
        });

        if (!reminders.length) {
          for (let index = 0; index < localStorage.length; index += 1) {
            const key = localStorage.key(index);
            if (!key || triedKeys.has(key) || !/remind/i.test(key)) continue;
            triedKeys.add(key);
            try {
              const value = localStorage.getItem(key);
              if (!value) continue;
              const parsed = JSON.parse(value);
              if (Array.isArray(parsed)) {
                parsed.forEach((item) => reminders.push(item));
              } else if (parsed && typeof parsed === 'object') {
                if (Array.isArray(parsed.items)) parsed.items.forEach((item) => reminders.push(item));
                if (Array.isArray(parsed.reminders)) parsed.reminders.forEach((item) => reminders.push(item));
              }
            } catch {
              // ignore
            }
          }
        }

        return reminders.map(normaliseReminder).filter(Boolean);
      };

      const collectReminders = () => {
        const fromDom = collectFromDom();
        if (fromDom.length) return fromDom;
        return collectFromStorage();
      };

      const toggleBusy = (isBusy) => {
        if (isBusy) {
          syncAllBtn?.setAttribute('aria-busy', 'true');
          syncAllBtn?.setAttribute('disabled', 'disabled');
          testSyncBtn?.setAttribute('aria-busy', 'true');
          testSyncBtn?.setAttribute('disabled', 'disabled');
        } else {
          syncAllBtn?.removeAttribute('aria-busy');
          testSyncBtn?.removeAttribute('aria-busy');
          updateButtonState();
        }
      };

      const updateButtonState = () => {
        const hasUrl = Boolean((syncUrlInput?.value || '').trim() || getStoredUrl());
        if (hasUrl) {
          syncAllBtn?.removeAttribute('disabled');
          testSyncBtn?.removeAttribute('disabled');
        } else {
          syncAllBtn?.setAttribute('disabled', 'disabled');
          testSyncBtn?.setAttribute('disabled', 'disabled');
        }
      };

      const storedUrl = getStoredUrl();
      if (syncUrlInput && storedUrl) {
        syncUrlInput.value = storedUrl;
      }

      updateButtonState();
      setStatus(navigator.onLine ? 'online' : 'offline');

      window.addEventListener('online', updateOnlineState);
      window.addEventListener('offline', updateOnlineState);

      syncUrlInput?.addEventListener('input', updateButtonState);

      saveSettingsBtn?.addEventListener('click', () => {
        const value = (syncUrlInput?.value || '').trim();
        if (!value) {
          persistUrl('');
          setStatus('info', 'Sync URL cleared. Add one to enable sync.');
          updateButtonState();
          return;
        }

        try {
          const parsed = new URL(value);
          if (!/^https?:/.test(parsed.protocol)) {
            throw new Error('Invalid protocol');
          }
        } catch {
          setStatus('error', 'Enter a valid sync URL before saving.');
          return;
        }

        persistUrl(value);
        setStatus('online', 'Sync settings saved.');
        updateButtonState();
      });

      testSyncBtn?.addEventListener('click', async () => {
        const url = (syncUrlInput?.value || getStoredUrl()).trim();
        if (!url) {
          setStatus('error', 'Add your sync URL in Settings first.');
          return;
        }

        toggleBusy(true);
        setStatus('syncing', 'Testing connection‚Ä¶');

        try {
          const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ test: true }),
          });
          if (response.ok) {
            setStatus('online', 'Connection looks good.');
          } else {
            setStatus('error', 'Test failed. Check your Apps Script deployment.');
          }
        } catch (error) {
          console.error('Test sync failed', error);
          setStatus('error', 'Test failed. Check your Apps Script deployment.');
        } finally {
          toggleBusy(false);
        }
      });

      syncAllBtn?.addEventListener('click', async () => {
        const url = (syncUrlInput?.value || getStoredUrl()).trim();
        if (!url) {
          setStatus('error', 'Add your sync URL in Settings first.');
          return;
        }

        const reminders = collectReminders();
        if (!reminders.length) {
          setStatus('info', 'Nothing to sync right now.');
          return;
        }

        toggleBusy(true);
        setStatus('syncing', `Syncing ${reminders.length} reminder${reminders.length === 1 ? '' : 's'}‚Ä¶`);

        const chunkSize = 20;
        let okCount = 0;
        let failCount = 0;

        const makePayload = (reminder) => ({
          id: reminder.id,
          title: reminder.title,
          dueIso: reminder.dueIso || null,
          priority: reminder.priority || 'Medium',
          category: reminder.category || 'General',
          done: Boolean(reminder.done),
          source: 'memory-cue-mobile',
        });

        try {
          for (let index = 0; index < reminders.length; index += chunkSize) {
            const slice = reminders.slice(index, index + chunkSize);
            const results = await Promise.allSettled(slice.map((reminder) => (
              fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(makePayload(reminder)),
              })
            )));

            results.forEach((result) => {
              if (result.status === 'fulfilled' && result.value?.ok) {
                okCount += 1;
              } else if (result.status === 'fulfilled') {
                failCount += 1;
              } else {
                failCount += 1;
              }
            });

            await new Promise((resolve) => setTimeout(resolve, 300));
          }

          if (!failCount) {
            setStatus('online', `Sync complete. ${okCount} updated.`);
          } else if (!okCount) {
            setStatus('error', 'Sync failed. Check your sync URL and retry.');
          } else {
            setStatus('error', `Partial sync: ${okCount} success, ${failCount} failed.`);
          }
        } catch (error) {
          console.error('Sync failed', error);
          setStatus('error', 'Sync failed. Try again soon.');
        } finally {
          toggleBusy(false);
        }
      });
    })();
  </script>
  
</body>
</html>

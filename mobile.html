<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <base href="/memory-cue/" />
  <!-- Production CSS: compiled via Tailwind/PostCSS; build rewrites this to a hashed asset -->
  <link rel="stylesheet" href="./styles/index.css" />
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Memory Cue (Mobile) — Inline + Edit + Sync All</title>
  <meta name="theme-color" content="#0f172a" />
  <link rel="manifest" href="./manifest.webmanifest" id="manifestLink" />
  <link rel="icon" href="./icons/icon-192.svg" type="image/svg+xml" />
  <link rel="stylesheet" href="./styles/tokens.css" />
  <link rel="stylesheet" href="./styles/a11y.css" />
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/daisyui@4.12.10/dist/full.min.css"
    integrity="sha384-yxrQVVFFRZdq4Z/YbeTDzSYbn1W6VnVonm2vAgnxtxUMehcccE4k2NufOz2tJnOe"
    crossorigin="anonymous"
  />
  <link rel="stylesheet" href="./styles/daisy-themes.css" />
  <style>
    .sync-status {
      --indicator-color: rgba(100, 116, 139, 0.9);
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      padding: 0.125rem 0.25rem;
      border-radius: 9999px;
      font-size: 0.75rem;
      font-weight: 600;
      color: rgb(71 85 105);
      transition: color 0.2s ease;
    }
    .sync-status::before {
      content: '';
      width: 0.6rem;
      height: 0.6rem;
      border-radius: 9999px;
      background-color: var(--indicator-color);
      box-shadow: 0 0 0 2px rgba(15, 23, 42, 0.08);
      flex-shrink: 0;
    }
    .sync-status[data-compact='true'] {
      padding: 0;
      gap: 0;
      min-width: 0.6rem;
      min-height: 0.6rem;
    }
    .sync-status[data-compact='true']::before {
      box-shadow: none;
    }
    .navbar .flex-1 {
      min-width: 0;
    }
    .navbar .sync-status {
      max-width: min(60vw, 14rem);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex-shrink: 1;
    }
    .dark .sync-status {
      color: rgb(148 163 184);
      --indicator-color: rgba(148, 163, 184, 0.9);
    }
    .sync-status.online {
      color: rgb(22 163 74);
      --indicator-color: rgb(34, 197, 94);
    }
    .dark .sync-status.online {
      color: rgb(134 239 172);
      --indicator-color: rgb(74, 222, 128);
    }
    .sync-status.error {
      color: rgb(220 38 38);
      --indicator-color: rgb(248, 113, 113);
    }
    .dark .sync-status.error {
      color: rgb(248 113 113);
      --indicator-color: rgb(252, 165, 165);
    }
    .sync-status.offline {
      color: rgb(220 38 38);
      --indicator-color: rgb(248, 113, 113);
    }
    .dark .sync-status.offline {
      color: rgb(248 113 113);
      --indicator-color: rgb(252, 165, 165);
    }
    .notes-editor {
      min-height: 10rem;
      width: 100%;
      border-radius: 0.75rem;
      border: 1px solid rgba(148, 163, 184, 0.5);
      padding: 0.75rem 1rem;
      background-color: rgba(255, 255, 255, 0.9);
      color: inherit;
      white-space: pre-wrap;
      overflow-wrap: break-word;
      line-height: 1.5;
      outline: none;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .dark .notes-editor {
      border-color: rgba(148, 163, 184, 0.35);
      background-color: rgba(15, 23, 42, 0.65);
    }
    .notes-editor:focus-visible {
      border-color: rgb(37 99 235);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
    }
    .notes-editor:empty::before {
      content: attr(data-placeholder);
      color: rgba(100, 116, 139, 0.7);
    }
    .dark .notes-editor:empty::before {
      color: rgba(148, 163, 184, 0.7);
    }
    .notes-editor ul,
    .notes-editor ol {
      margin: 0.25rem 0 0.25rem 1.25rem;
      padding-left: 0.75rem;
    }
    .notes-editor ul li,
    .notes-editor ol li {
      margin-bottom: 0.25rem;
    }
    .notes-editor--columns {
      column-width: 16rem;
      column-gap: 1.5rem;
    }
    .view-panel {
      display: grid;
      gap: 1.5rem;
    }
    .section-jump {
      display: flex;
      gap: 0.5rem;
      overflow-x: auto;
      padding-bottom: 0.25rem;
      scrollbar-width: none;
      scroll-snap-type: x proximity;
    }
    .section-jump::-webkit-scrollbar {
      display: none;
    }
    .section-jump .btn {
      scroll-snap-align: start;
    }
    .glass-panel {
      background-color: rgba(248, 250, 252, 0.85);
      backdrop-filter: blur(12px);
    }
    .dark .glass-panel {
      background-color: rgba(15, 23, 42, 0.88);
    }
    .task-item[data-today="true"],
    .task-item.is-today {
      position: relative;
      border: 1px solid rgba(59, 130, 246, 0.35);
      border-left-width: 4px;
      border-left-color: rgba(37, 99, 235, 0.7);
      background: linear-gradient(135deg, rgba(191, 219, 254, 0.28), rgba(191, 219, 254, 0.08));
      box-shadow: 0 12px 26px -16px rgba(30, 64, 175, 0.55);
    }
    .dark .task-item[data-today="true"],
    .dark .task-item.is-today {
      border-color: rgba(96, 165, 250, 0.55);
      border-left-color: rgba(191, 219, 254, 0.85);
      background: linear-gradient(135deg, rgba(30, 64, 175, 0.5), rgba(30, 58, 138, 0.25));
      box-shadow: 0 12px 26px -16px rgba(30, 64, 175, 0.7);
    }
  </style>
  <!-- Skip-link CSS: fully hidden until keyboard focus -->
  <style id="skip-link-css">
    .skip-link {
      position: absolute;
      left: -9999px;
      top: auto;
      width: 1px;
      height: 1px;
      overflow: hidden;
    }
    .skip-link:focus-visible {
      left: 16px;
      top: 16px;
      width: auto;
      height: auto;
      overflow: visible;
      z-index: 50;
      border-radius: 9999px; padding: 8px 12px;
      background: var(--fallback-p, #2563eb); color: var(--fallback-pc, #fff);
      box-shadow: 0 2px 6px rgba(0,0,0,.15);
    }
  </style>
  <!-- BEGIN GPT CHANGE: bottom sheet styles -->
  <style>
    :root {
      --vh: 1vh;
    }

    body,
    .min-h-screen {
      min-height: calc(var(--vh, 1vh) * 100);
    }

    .hidden {
      display: none !important;
    }
    .sheet {
      position: fixed;
      inset: 0;
      min-height: calc(var(--vh, 1vh) * 100);
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      z-index: 90;
    }
    .sheet-panel {
      position: relative;
      left: 0;
      right: 0;
      bottom: 0;
      max-height: calc(var(--vh, 1vh) * 85);
      overflow: auto;
      border-top-left-radius: 16px;
      border-top-right-radius: 16px;
      background: var(--fallback-b1, #ffffff);
      color: inherit;
      box-shadow: 0 -16px 32px rgba(15, 23, 42, 0.25);
      padding: 16px;
    }
    .dark .sheet-panel {
      background: rgba(30, 41, 59, 0.97);
    }
    .sheet-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding-bottom: 12px;
      gap: 12px;
    }
    .sheet-header-actions {
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }
    .sheet-header-actions .btn.is-listening {
      background: var(--fallback-p, #2563eb);
      color: var(--fallback-pc, #fff);
    }
    .sheet-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(15, 23, 42, 0.45);
    }
    #settingsModal {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 80;
    }
    .modal-panel {
      position: relative;
      max-width: 420px;
      width: calc(100% - 32px);
      background: var(--fallback-b1, #ffffff);
      color: inherit;
      border-radius: 16px;
      box-shadow: 0 20px 40px rgba(15, 23, 42, 0.3);
      overflow: hidden;
    }
    .dark .modal-panel {
      background: rgba(30, 41, 59, 0.97);
    }
    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.3);
    }
    .modal-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(15, 23, 42, 0.55);
    }
  </style>
  <style id="add-task-stability-css">
    /* Make sure modal/sheet stays interactive and above other layers */
    [data-add-task-dialog] {
      position: fixed;
      inset: 0;
      z-index: 60;
    }
    [data-add-task-dialog] [data-dialog-content] {
      position: relative;
      z-index: 61;
      pointer-events: auto;
    }
    /* Backdrop element (if you have one) should sit under content but accept clicks */
    [data-add-task-dialog] .backdrop {
      position: absolute;
      inset: 0;
      z-index: 59;
    }
  </style>
  <!-- END GPT CHANGE: bottom sheet styles -->
  <!-- BEGIN GPT CHANGE: rhythm -->
  <style>
    .card-body.compact {
      gap: 0.5rem;
    }
    .inputs-compact input,
    .inputs-compact select,
    .inputs-compact textarea,
    .inputs-compact button {
      padding-top: 8px;
      padding-bottom: 8px;
    }
    main {
      padding-bottom: 96px;
    }
    .chip-row {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    .chip-row label {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 6px 12px;
      border-radius: 9999px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      cursor: pointer;
      font-size: 0.875rem;
    }
    .chip-row input[type='radio'] {
      accent-color: currentColor;
    }
    .voice-add-wrap {
      display: none !important;
    }
    .focus-list,
    .focus-detail {
      display: none !important;
    }
    #toggleUiBtn {
      display: none !important;
    }
  </style>
  <!-- END GPT CHANGE: rhythm -->
  <style id="min-expand-css">
    /* Expand/collapse behavior */
    .task-row-min {
      cursor: pointer;
      outline: none;
    }
    .task-row-min:focus {
      box-shadow: 0 0 0 2px rgba(0,0,0,.15) inset;
    }
    .task-row-min .min-notes {
      display: none;
      grid-column: 1 / -1;
      margin-top: 8px;
      font-size: 14px;
      line-height: 1.35;
      opacity: .95;
      white-space: pre-wrap;
    }
    .task-row-min.expanded .min-notes {
      display: block;
    }
    /* Slightly larger title when expanded */
    .task-row-min.expanded .title {
      font-weight: 600;
    }
    /* Optional small chevron indicator */
    .task-row-min::after {
      content: "▾";
      justify-self: end;
      opacity: .5;
      font-size: 12px;
    }
    .task-row-min.expanded::after { transform: rotate(180deg); }

  </style>
  <style id="empty-state-compact-css">
    #emptyState {
      text-align: left;
    }
    #emptyState .empty-state-compact {
      display: grid;
      gap: 0.75rem;
      justify-items: start;
      text-align: left;
      width: 100%;
    }
    #emptyState .empty-state-compact h3 {
      font-size: 1rem;
      font-weight: 600;
      line-height: 1.4;
    }
    #emptyState .empty-state-compact p {
      font-size: 0.875rem;
      line-height: 1.5;
      color: rgba(71, 85, 105, 0.85);
    }
    .dark #emptyState .empty-state-compact p {
      color: rgba(226, 232, 240, 0.8);
    }
    #emptyState .empty-state-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      width: 100%;
    }
    #emptyState .empty-state-actions > * {
      flex: 1 1 auto;
    }
  </style>
</head>
<body class="min-h-screen bg-base-200 text-base-content show-full">
  <a class="sr-only focus:not-sr-only focus:fixed focus:left-4 focus:top-4 focus:z-50 focus:rounded-full focus:bg-primary focus:px-4 focus:py-2 focus:text-sm focus:font-semibold focus:text-primary-content" href="#main">Skip to main content</a>

  <header class="navbar navbar-glass sticky top-0 z-50 px-3">
    <div class="flex-1 items-center gap-3">
      <span
        class="inline-flex size-9 items-center justify-center rounded-full bg-primary text-primary-content text-sm font-semibold tracking-tight shadow-sm"
        aria-hidden="true"
      >
        MC
      </span>
      <div class="flex flex-col leading-tight">
        <span class="text-base font-semibold">Memory Cue</span>
        <span
          id="syncStatus"
          class="sync-status text-xs"
          role="status"
          aria-live="polite"
          aria-atomic="true"
        >
          Offline
        </span>
      </div>
    </div>
    <div class="flex-none flex items-center gap-2">
      <button
        id="inlineQuickAddBtn"
        class="btn btn-primary btn-sm gap-1"
        type="button"
        data-open-add-task
      >
        <svg
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          stroke-width="1.8"
          stroke-linecap="round"
          stroke-linejoin="round"
          class="size-4"
          aria-hidden="true"
        >
          <path d="M12 5v14" />
          <path d="M5 12h14" />
        </svg>
        <span class="text-sm font-semibold">Quick add</span>
      </button>
      <div class="relative">
        <button
          id="headerMenuBtn"
          class="btn btn-ghost btn-sm btn-circle"
          type="button"
          aria-haspopup="menu"
          aria-expanded="false"
          aria-controls="headerMenu"
        >
          <span class="sr-only">Open menu</span>
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="1.8"
            stroke-linecap="round"
            stroke-linejoin="round"
            class="size-5"
            aria-hidden="true"
          >
            <circle cx="5" cy="12" r="1.5" />
            <circle cx="12" cy="12" r="1.5" />
            <circle cx="19" cy="12" r="1.5" />
          </svg>
        </button>
        <div
          id="headerMenu"
          class="absolute right-0 mt-3 hidden w-56 rounded-box bg-base-100 p-2 shadow focus:outline-none flex flex-col gap-2 z-50"
          role="menu"
          aria-labelledby="headerMenuBtn"
        >
          <button
            id="voiceAddBtn"
            class="btn btn-ghost btn-sm justify-start gap-2"
            type="button"
            role="menuitem"
          >
            <span aria-hidden="true">🎙️</span>
            <span>Dictate reminder</span>
          </button>
          <div class="h-px bg-base-300" role="presentation"></div>
          <button
            id="openSettings"
            class="btn btn-ghost btn-sm justify-start gap-2"
            type="button"
            role="menuitem"
          >
            Settings
          </button>
          <button
            id="themeToggle"
            class="btn btn-ghost btn-sm justify-start gap-2"
            type="button"
            role="menuitem"
          >
            Theme
          </button>
          <div class="h-px bg-base-300" role="presentation"></div>
          <button
            id="googleSignInBtn"
            class="btn btn-primary btn-sm justify-start gap-2"
            type="button"
            role="menuitem"
          >
            Sign in
          </button>
          <button
            id="googleSignOutBtn"
            class="btn btn-ghost btn-sm justify-start gap-2 hidden"
            type="button"
            role="menuitem"
          >
            Sign out
          </button>
        </div>
      </div>
    </div>
  </header>
  <p id="googleUserName" class="px-3 text-xs text-base-content/70"></p>

  <main id="main" class="max-w-md mx-auto px-4 pt-4 pb-4" tabindex="-1" data-active-view="reminders">
    <!-- BEGIN GPT CHANGE: create form moved to bottom sheet -->
    <!-- END GPT CHANGE -->
    <!-- BEGIN GPT CHANGE: reminders view -->
    <section data-view="reminders" id="view-reminders" class="view-panel">
      <!-- Quick add form -->
      <section id="quickAddBar" class="card bg-base-100 border" aria-label="Quick add reminder">
        <div class="card-body gap-3 compact">
          <div class="flex items-center gap-2">
            <input id="quickAddInput"
                   type="text"
                   class="input input-bordered flex-1"
                   placeholder="What do you need to remember?"
                   aria-label="Quick add reminder"
                   autocomplete="off" />
            <button id="quickAddVoiceBtn"
                    type="button"
                    class="btn btn-ghost"
                    title="Dictate quick reminder"
                    aria-label="Dictate quick reminder"
                    aria-pressed="false">
              <span aria-hidden="true">🎙️</span>
              <span class="sr-only">Start voice input for quick add</span>
            </button>
            <button id="quickAddSubmit"
                    class="btn btn-primary"
                    type="button"
                    aria-label="Add reminder now">Add</button>
          </div>
          <p class="text-xs text-base-content/60">
            Tip: Press <kbd>/</kbd> or <kbd>q</kbd> to focus; press <kbd>Enter</kbd> to add instantly.
          </p>
        </div>
      </section>
      
      <section id="reminderListSection" class="card bg-base-100 border">
        <div class="card-body gap-4 compact" id="remindersWrapper">
          <div id="emptyState" class="hidden text-center text-base-content/60"></div>
          <ul id="reminderList" class="space-y-3"></ul>
          <p class="text-xs text-base-content/60">Total reminders: <span id="totalCount">0</span></p>
        </div>
      </section>
    </section>
    <!-- END GPT CHANGE -->
    <!-- BEGIN GPT CHANGE: notebook view -->
    <section data-view="notebook" id="view-notebook" class="view-panel hidden">
      <section class="card bg-base-100 border">
        <div class="card-body gap-3 compact">
          <div class="flex items-center justify-between gap-2">
            <h2 class="card-title text-base">Scratch Notes</h2>
            <button type="button" class="btn btn-ghost btn-xs" data-jump-view="reminders">Back to reminders</button>
          </div>
          <div
            id="notesToolbar"
            class="flex flex-wrap gap-2"
            role="toolbar"
            aria-label="Scratch notes formatting options"
            aria-controls="notes"
          >
            <button type="button" class="btn btn-xs" data-action="bullets">• Bullets</button>
            <button type="button" class="btn btn-xs" data-action="numbers">1. Numbers</button>
            <button
              type="button"
              class="btn btn-xs"
              data-action="columns"
              aria-pressed="false"
            >
              Columns
            </button>
          </div>
          <div
            id="notes"
            class="notes-editor"
            contenteditable="true"
            role="textbox"
            aria-multiline="true"
            spellcheck="true"
            data-placeholder="Quick personal notes"
          ></div>
          <div class="flex gap-2">
            <button id="saveNotes" class="btn btn-outline flex-1" type="button">Save notes</button>
            <button id="loadNotes" class="btn btn-outline flex-1" type="button">Load notes</button>
          </div>
        </div>
      </section>

    </section>
    <!-- END GPT CHANGE -->
</main>

  <nav class="btm-nav fixed bottom-0 left-0 right-0 bg-base-100 border-t" aria-label="Primary navigation">
    <button type="button" aria-current="page" class="active">
      <span class="btm-nav-label">Reminders</span>
    </button>
    <button type="button">
      <span class="btm-nav-label">Notebook</span>
    </button>
  </nav>
  <!-- build-marker: mobile.html / runs mobile.js / EXPECTED LIVE -->
  <!-- When deployed, this should appear in View Source with today’s date. -->

  <script>
    window.memoryCueEmptyStateCtaClasses = 'btn btn-primary btn-sm w-full sm:w-auto';
    window.memoryCueMountEmptyState = function mountCompactEmptyState(target, config) {
      if (!(target instanceof HTMLElement)) {
        return;
      }

      const { title, description, action } = config || {};
      const wrapper = document.createElement('div');
      wrapper.className = 'empty-state-compact';
      wrapper.setAttribute('role', 'presentation');

      if (title) {
        const heading = document.createElement('h3');
        heading.textContent = title;
        wrapper.appendChild(heading);
      }

      if (description) {
        const paragraph = document.createElement('p');
        paragraph.textContent = description;
        wrapper.appendChild(paragraph);
      }

      if (action) {
        const actions = document.createElement('div');
        actions.className = 'empty-state-actions';
        actions.innerHTML = action;
        wrapper.appendChild(actions);
      }

      target.replaceChildren(wrapper);
    };
  </script>
  <!-- Load the mobile app bundle (build will rewrite to hashed path) -->
  <script type="module" src="./mobile.js?v=2025-10-29-1"></script>
  <script type="module" src="./js/mobile-theme-toggle.js"></script>
  <!-- BEGIN GPT CHANGE: bottom sheet for Create Reminder -->
  <div id="create-sheet" role="dialog" aria-modal="true" aria-labelledby="createSheetTitle" class="sheet hidden" tabindex="-1" data-add-task-dialog>
    <div class="sheet-panel bg-base-100 border-t border-base-200" data-dialog-content>
      <header class="sheet-header">
        <h2 id="createSheetTitle">Create Reminder</h2>
        <div class="sheet-header-actions">
          <button
            id="voiceBtn"
            type="button"
            class="btn btn-circle btn-ghost"
            aria-label="Start voice input"
            aria-pressed="false"
            title="Fill reminder using your voice"
          >
            <span aria-hidden="true">🎙️</span>
            <span class="sr-only">Start voice input</span>
          </button>
          <button type="button" id="closeCreateSheet" aria-label="Close">✕</button>
        </div>
      </header>
      <form id="createReminderForm" class="inputs-compact">
        <div class="card-body gap-4 compact">
          <label class="form-control w-full">
            <div class="label"><span class="label-text">Reminder</span></div>
            <input
              id="reminderText"
              type="text"
              placeholder="e.g., Call Alex at 3pm"
              class="input input-bordered w-full"
              autocomplete="off"
            />
          </label>

          <label class="form-control w-full">
            <div class="label"><span class="label-text">Notes</span></div>
            <textarea
              id="reminderDetails"
              class="textarea textarea-bordered"
              rows="3"
              placeholder="Optional context for the reminder"
            ></textarea>
          </label>

          <div class="grid grid-cols-2 gap-3">
            <label class="form-control">
              <div class="label"><span class="label-text">Date</span></div>
              <input id="reminderDate" type="date" class="input input-bordered" />
            </label>
            <label class="form-control">
              <div class="label"><span class="label-text">Time</span></div>
              <input id="reminderTime" type="time" class="input input-bordered" />
            </label>
          </div>

          <div id="dateFeedback" class="text-xs text-info"></div>

          <div class="grid grid-cols-2 gap-3">
            <div class="form-control">
              <div class="label"><span class="label-text">Priority</span></div>
              <select id="priority" class="select select-bordered hidden" aria-hidden="true" tabindex="-1">
                <option value="High">High</option>
                <option value="Medium" selected>Medium</option>
                <option value="Low">Low</option>
              </select>
              <!-- BEGIN GPT CHANGE: priority chips -->
              <fieldset id="priorityChips" aria-label="Priority" class="chip-row">
                <label><input type="radio" name="priority" value="High"> High</label>
                <label><input type="radio" name="priority" value="Medium" checked> Medium</label>
                <label><input type="radio" name="priority" value="Low"> Low</label>
              </fieldset>
              <!-- END GPT CHANGE: priority chips -->
            </div>
            <label class="form-control">
              <div class="label"><span class="label-text">Category</span></div>
              <input
                id="category"
                class="input input-bordered"
                list="categorySuggestions"
                placeholder="General"
                value="General"
              />
              <datalist id="categorySuggestions">
                <option value="General"></option>
                <option value="General Appointments"></option>
                <option value="Home &amp; Personal"></option>
                <option value="School – Appointments/Meetings"></option>
                <option value="School – Communication &amp; Families"></option>
                <option value="School – Excursions &amp; Events"></option>
                <option value="School – Grading &amp; Assessment"></option>
                <option value="School – Prep &amp; Resources"></option>
                <option value="School – To-Do"></option>
                <option value="Wellbeing &amp; Support"></option>
              </datalist>
            </label>
          </div>

          <div class="flex flex-wrap items-center gap-3">
            <button id="notifBtn" class="btn btn-ghost" type="button">Enable notifications</button>
          </div>

          <div class="flex flex-col gap-2">
            <button
              id="sheetVoiceBtn"
              class="btn btn-outline justify-center"
              type="button"
              aria-pressed="false"
              aria-label="Dictate reminder"
            >
              🎤 Voice input
            </button>
            <p
              id="sheetVoiceStatus"
              class="text-xs text-base-content/60"
              role="status"
              aria-live="polite"
              hidden
            >
              Tap the microphone to start speaking.
            </p>
          </div>

          <div class="card-actions justify-stretch">
            <button id="saveReminder" class="btn btn-primary w-full" type="button">Save Reminder</button>
            <button id="cancelEditBtn" class="btn btn-outline w-full hidden" type="button">Cancel</button>
          </div>
          <p id="statusMessage" class="text-sm text-base-content/70" role="status" aria-live="polite"></p>
        </div>
      </form>
    </div>
    <div class="sheet-backdrop backdrop" data-close></div>
  </div>
  <!-- END GPT CHANGE: bottom sheet for Create Reminder -->

  <!-- BEGIN GPT CHANGE: settings modal -->
  <div id="settingsModal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle" class="hidden">
    <div class="modal-panel">
      <header class="modal-header">
        <h2 id="settingsTitle">Settings</h2>
        <button type="button" id="closeSettings" aria-label="Close">✕</button>
      </header>
      <div class="card bg-base-100 border-0">
        <div class="card-body gap-4 compact">
          <h2 class="card-title text-base">Sync Settings</h2>
          <p class="text-sm text-base-content/70">Configure your Google Apps Script endpoint to sync reminders to Calendar.</p>
          <label class="form-control">
            <div class="label"><span class="label-text">Apps Script URL</span></div>
            <input id="syncUrl" type="url" class="input input-bordered" placeholder="https://script.google.com/macros/s/.../exec" />
          </label>
          <div class="card-actions flex-col gap-2">
            <div class="flex gap-2 w-full">
              <button id="saveSyncSettings" class="btn btn-outline flex-1" type="button">Save Settings</button>
              <button id="testSync" class="btn btn-outline flex-1" type="button">Test Connection</button>
            </div>
            <button id="syncAll" class="btn btn-primary w-full" type="button">Sync All</button>
          </div>
          <p class="text-xs text-base-content/60">Tip: In Google Apps Script choose <strong>Deploy → Web app</strong>, execute as yourself and allow access to anyone with the link.</p>
        </div>
      </div>
    </div>
    <div class="modal-backdrop" data-close></div>
  </div>
  <!-- END GPT CHANGE: settings modal -->

  <script id="mobile-enhancements">
    document.querySelectorAll('[data-close]').forEach((btn) => {
      btn.addEventListener('click', (event) => {
        const trigger = event.target;
        const dialog = trigger?.closest?.('.sheet, .modal');
        if (dialog) {
          dialog.classList.add('hidden');
        }
      });
    });

    (function () {
      const views = {
        reminders: document.querySelector('[data-view="reminders"]'),
        notebook: document.querySelector('[data-view="notebook"]'),
      };
      const nav = document.querySelector('.btm-nav');
      if (!nav) return;

      const buttons = Array.from(nav.querySelectorAll('button')).slice(0, 2);
      const order = ['reminders', 'notebook'];

      if (!buttons.length || order.some((key) => !views[key])) {
        return;
      }

      const reduceMotion = typeof window !== 'undefined' && typeof window.matchMedia === 'function'
        ? window.matchMedia('(prefers-reduced-motion: reduce)')
        : null;

      const setActiveView = (target) => {
        if (!order.includes(target)) return;

        order.forEach((key, index) => {
          const view = views[key];
          const button = buttons[index];
          const isActive = key === target;

          if (view) {
            view.classList.toggle('hidden', !isActive);
            view.setAttribute('aria-hidden', String(!isActive));
          }

          if (button) {
            button.setAttribute('aria-current', isActive ? 'page' : 'false');
            button.classList.toggle('active', Boolean(isActive));
          }
        });

        const skipLink =
          document.querySelector('.skip-link') ||
          document.querySelector('a[href$="#main"]');
        const main = document.getElementById('main') || document.querySelector('main');
        if (main) {
          main.setAttribute('data-active-view', target);
        }
        if (skipLink && main) {
          const behaviour = reduceMotion?.matches ? 'auto' : 'smooth';
          try {
            window.scrollTo({ top: 0, behavior: behaviour });
          } catch {
            window.scrollTo(0, 0);
          }
        }
      };

      buttons.forEach((button, index) => {
        button.addEventListener('click', () => {
          setActiveView(order[index]);
        });
      });

      document.querySelectorAll('[data-jump-view]').forEach((control) => {
        control.addEventListener('click', () => {
          const target = control.getAttribute('data-jump-view');
          if (target) {
            setActiveView(target);
          }
        });
      });

      document.querySelectorAll('[data-scroll-target]').forEach((control) => {
        control.addEventListener('click', () => {
          const targetId = control.getAttribute('data-scroll-target');
          if (!targetId) return;
          const el = document.getElementById(targetId);
          if (!el) return;
          try {
            el.scrollIntoView({ behavior: 'smooth', block: 'start' });
          } catch {
            el.scrollIntoView(true);
          }
        });
      });

      setActiveView('reminders');
    })();

    (function () {
      const list = document.getElementById('reminderList');
      if (!list) return;

      const allChildren = Array.from(list.children);
      if (allChildren.length <= 30) return;

      const PAGE_SIZE = 20;
      list.innerHTML = '';
      let index = 0;

      const appendPage = () => {
        const slice = allChildren.slice(index, index + PAGE_SIZE);
        slice.forEach((node) => list.appendChild(node));
        index += slice.length;
      };

      appendPage();

      const sentinel = document.createElement('div');
      sentinel.id = 'listSentinel';
      list.appendChild(sentinel);

      const observer = new IntersectionObserver((entries) => {
        if (entries.some((entry) => entry.isIntersecting) && index < allChildren.length) {
          appendPage();
          if (index >= allChildren.length) {
            observer.disconnect();
          }
        }
      });

      observer.observe(sentinel);
    })();

    (function () {
      const openBtn = document.querySelector('[data-open="settings"]') || document.getElementById('openSettings');
      const modal = document.getElementById('settingsModal');
      const closeBtn = document.getElementById('closeSettings');
      if (!openBtn || !modal || !closeBtn) return;

      const open = () => {
        modal.classList.remove('hidden');
      };

      const close = () => {
        modal.classList.add('hidden');
      };

      openBtn.addEventListener('click', open);
      closeBtn.addEventListener('click', close);
      modal.addEventListener('click', (event) => {
        if (event.target instanceof HTMLElement && event.target.matches('[data-close]')) {
          close();
        }
      });
      modal.addEventListener('keydown', (event) => {
        if (event.key === 'Escape') {
          close();
        }
      });
    })();

    (function () {
      const syncStatusEl = document.getElementById('syncStatus');
      if (!syncStatusEl) return;

      const syncUrlInput = document.getElementById('syncUrl');
      const saveSettingsBtn = document.getElementById('saveSyncSettings');
      const testSyncBtn = document.getElementById('testSync');
      const syncAllBtn = document.getElementById('syncAll');
      const STORAGE_KEY = 'syncUrl';
      const ACTIVE_CLASSES = ['online', 'offline', 'error'];

      let currentState = null;

      const DEFAULT_MESSAGES = {
        checking: 'Checking connection…',
        syncing: 'Syncing your latest changes…',
        online: 'Connected. Changes sync automatically.',
        offline: "You're offline. Changes are saved on this device until you reconnect.",
        error: "We couldn't sync right now. We'll retry soon.",
        info: '',
      };

      const DISPLAY_MESSAGES = {
        checking: 'Checking…',
        syncing: 'Syncing…',
        online: 'Synced. Auto-save on.',
        offline: 'Offline. Saving locally.',
        error: 'Sync issue. Retrying.',
        info: '',
      };

      const setStatus = (state, message) => {
        currentState = state;
        ACTIVE_CLASSES.forEach((cls) => syncStatusEl.classList.remove(cls));

        if (state === 'online' || state === 'offline') {
          syncStatusEl.classList.add(state);
        } else if (state === 'error') {
          syncStatusEl.classList.add('error');
        }

        const fullText =
          typeof message === 'string' && message.trim()
            ? message.trim()
            : DEFAULT_MESSAGES[state] || '';

        const displayText =
          typeof message === 'string' && message.trim()
            ? message.trim()
            : DISPLAY_MESSAGES[state] || fullText;

        syncStatusEl.dataset.state = state;

        const isDotState = state === 'online' || state === 'offline';
        if (isDotState) {
          syncStatusEl.textContent = '';
          syncStatusEl.setAttribute('data-compact', 'true');
          if (fullText) {
            syncStatusEl.setAttribute('title', fullText);
            syncStatusEl.setAttribute('aria-label', fullText);
          } else {
            syncStatusEl.removeAttribute('title');
            syncStatusEl.removeAttribute('aria-label');
          }
        } else {
          syncStatusEl.textContent = displayText;
          syncStatusEl.removeAttribute('data-compact');
          if (fullText) {
            syncStatusEl.setAttribute('title', fullText);
            if (displayText !== fullText) {
              syncStatusEl.setAttribute('aria-label', fullText);
            } else {
              syncStatusEl.removeAttribute('aria-label');
            }
          } else {
            syncStatusEl.removeAttribute('title');
            syncStatusEl.removeAttribute('aria-label');
          }
        }
      };

      const updateOnlineState = () => {
        if (currentState === 'syncing') return;
        if (navigator.onLine) {
          if (currentState !== 'online') setStatus('online');
        } else {
          setStatus('offline');
        }
      };

      const persistUrl = (value) => {
        if (typeof localStorage === 'undefined') return;
        if (value) {
          localStorage.setItem(STORAGE_KEY, value);
        } else {
          localStorage.removeItem(STORAGE_KEY);
        }
      };

      const getStoredUrl = () => {
        if (typeof localStorage === 'undefined') return '';
        try {
          return localStorage.getItem(STORAGE_KEY) || '';
        } catch {
          return '';
        }
      };

      const normaliseReminder = (raw) => {
        if (!raw || typeof raw !== 'object') return null;
        const id = raw.id || raw.uid || raw.key || raw.slug || raw.uuid;
        let title = typeof raw.title === 'string' ? raw.title.trim() : '';
        if (!title && typeof raw.name === 'string') {
          title = raw.name.trim();
        }
        if (!title) return null;

        const dueIso = typeof raw.dueIso === 'string' && raw.dueIso
          ? raw.dueIso
          : (typeof raw.due === 'string' ? raw.due : null);

        const priority = typeof raw.priority === 'string' && raw.priority.trim()
          ? raw.priority.trim()
          : (raw.level || raw.importance || 'Medium');

        const category = typeof raw.category === 'string' && raw.category.trim()
          ? raw.category.trim()
          : (raw.group || raw.bucket || 'General');

        const done = typeof raw.done === 'boolean'
          ? raw.done
          : Boolean(raw.completed || raw.isDone || raw.status === 'done');

        const ensuredId = id || (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function'
          ? crypto.randomUUID()
          : `${Date.now()}-${Math.random()}`);

        return {
          id: ensuredId,
          title,
          dueIso: dueIso && dueIso.trim() ? dueIso.trim() : null,
          priority,
          category,
          done,
        };
      };

      const collectFromDom = () => {
        const elements = Array.from(document.querySelectorAll('[data-reminder]'));
        if (!elements.length) return [];

        return elements
          .map((el) => {
            const dataset = el.dataset || {};
            let raw = null;

            if (dataset.reminder) {
              try {
                const parsed = JSON.parse(dataset.reminder);
                if (parsed && typeof parsed === 'object') {
                  raw = parsed;
                }
              } catch {
                raw = null;
              }
            }

            const candidate = raw || {
              id: dataset.id || dataset.reminderId || el.getAttribute('data-id') || null,
              title: dataset.title || dataset.reminderTitle || '',
              dueIso: dataset.due || dataset.reminderDue || el.getAttribute('data-due') || null,
              priority: dataset.priority || dataset.reminderPriority || el.getAttribute('data-priority') || '',
              category: dataset.category || dataset.reminderCategory || el.getAttribute('data-category') || '',
              done: dataset.done === 'true' || dataset.reminderDone === 'true' || el.getAttribute('data-done') === 'true',
            };

            if (!candidate.title) {
              const titleEl = el.querySelector('[data-reminder-title], [data-title], h3, h4, strong');
              if (titleEl) {
                candidate.title = titleEl.textContent.trim();
              }
            }

            if (!candidate.dueIso) {
              const dueEl = el.querySelector('[data-due], time');
              if (dueEl) {
                const attr = dueEl.getAttribute('datetime') || dueEl.getAttribute('data-due');
                candidate.dueIso = attr || dueEl.textContent.trim();
              }
            }

            return normaliseReminder(candidate);
          })
          .filter(Boolean);
      };

      const collectFromStorage = () => {
        if (typeof localStorage === 'undefined') return [];
        const reminders = [];
        const triedKeys = new Set();
        const preferredKeys = [
          'memoryCue.reminders.v1',
          'memoryCue.reminders',
          'memoryCueMobile.reminders',
          'memoryCue.reminders.cache',
          'reminders',
        ];

        preferredKeys.forEach((key) => {
          if (triedKeys.has(key)) return;
          triedKeys.add(key);
          try {
            const value = localStorage.getItem(key);
            if (!value) return;
            const parsed = JSON.parse(value);
            if (Array.isArray(parsed)) {
              parsed.forEach((item) => reminders.push(item));
            } else if (parsed && typeof parsed === 'object') {
              if (Array.isArray(parsed.items)) parsed.items.forEach((item) => reminders.push(item));
              if (Array.isArray(parsed.reminders)) parsed.reminders.forEach((item) => reminders.push(item));
            }
          } catch {
            // ignore invalid storage entries
          }
        });

        if (!reminders.length) {
          for (let index = 0; index < localStorage.length; index += 1) {
            const key = localStorage.key(index);
            if (!key || triedKeys.has(key) || !/remind/i.test(key)) continue;
            triedKeys.add(key);
            try {
              const value = localStorage.getItem(key);
              if (!value) continue;
              const parsed = JSON.parse(value);
              if (Array.isArray(parsed)) {
                parsed.forEach((item) => reminders.push(item));
              } else if (parsed && typeof parsed === 'object') {
                if (Array.isArray(parsed.items)) parsed.items.forEach((item) => reminders.push(item));
                if (Array.isArray(parsed.reminders)) parsed.reminders.forEach((item) => reminders.push(item));
              }
            } catch {
              // ignore
            }
          }
        }

        return reminders.map(normaliseReminder).filter(Boolean);
      };

      const collectReminders = () => {
        const fromDom = collectFromDom();
        if (fromDom.length) return fromDom;
        return collectFromStorage();
      };

      const toggleBusy = (isBusy) => {
        if (isBusy) {
          syncAllBtn?.setAttribute('aria-busy', 'true');
          syncAllBtn?.setAttribute('disabled', 'disabled');
          testSyncBtn?.setAttribute('aria-busy', 'true');
          testSyncBtn?.setAttribute('disabled', 'disabled');
        } else {
          syncAllBtn?.removeAttribute('aria-busy');
          testSyncBtn?.removeAttribute('aria-busy');
          updateButtonState();
        }
      };

      const updateButtonState = () => {
        const hasUrl = Boolean((syncUrlInput?.value || '').trim() || getStoredUrl());
        if (hasUrl) {
          syncAllBtn?.removeAttribute('disabled');
          testSyncBtn?.removeAttribute('disabled');
        } else {
          syncAllBtn?.setAttribute('disabled', 'disabled');
          testSyncBtn?.setAttribute('disabled', 'disabled');
        }
      };

      const storedUrl = getStoredUrl();
      if (syncUrlInput && storedUrl) {
        syncUrlInput.value = storedUrl;
      }

      updateButtonState();
      setStatus(navigator.onLine ? 'online' : 'offline');

      window.addEventListener('online', updateOnlineState);
      window.addEventListener('offline', updateOnlineState);

      syncUrlInput?.addEventListener('input', updateButtonState);

      saveSettingsBtn?.addEventListener('click', () => {
        const value = (syncUrlInput?.value || '').trim();
        if (!value) {
          persistUrl('');
          setStatus('info', 'Sync URL cleared. Add one to enable sync.');
          updateButtonState();
          return;
        }

        try {
          const parsed = new URL(value);
          if (!/^https?:/.test(parsed.protocol)) {
            throw new Error('Invalid protocol');
          }
        } catch {
          setStatus('error', 'Enter a valid sync URL before saving.');
          return;
        }

        persistUrl(value);
        setStatus('online', 'Sync settings saved.');
        updateButtonState();
      });

      testSyncBtn?.addEventListener('click', async () => {
        const url = (syncUrlInput?.value || getStoredUrl()).trim();
        if (!url) {
          setStatus('error', 'Add your sync URL in Settings first.');
          return;
        }

        toggleBusy(true);
        setStatus('syncing', 'Testing connection…');

        try {
          const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ test: true }),
          });
          if (response.ok) {
            setStatus('online', 'Connection looks good.');
          } else {
            setStatus('error', 'Test failed. Check your Apps Script deployment.');
          }
        } catch (error) {
          console.error('Test sync failed', error);
          setStatus('error', 'Test failed. Check your Apps Script deployment.');
        } finally {
          toggleBusy(false);
        }
      });

      syncAllBtn?.addEventListener('click', async () => {
        const url = (syncUrlInput?.value || getStoredUrl()).trim();
        if (!url) {
          setStatus('error', 'Add your sync URL in Settings first.');
          return;
        }

        const reminders = collectReminders();
        if (!reminders.length) {
          setStatus('info', 'Nothing to sync right now.');
          return;
        }

        toggleBusy(true);
        setStatus('syncing', `Syncing ${reminders.length} reminder${reminders.length === 1 ? '' : 's'}…`);

        const chunkSize = 20;
        let okCount = 0;
        let failCount = 0;

        const makePayload = (reminder) => ({
          id: reminder.id,
          title: reminder.title,
          dueIso: reminder.dueIso || null,
          priority: reminder.priority || 'Medium',
          category: reminder.category || 'General',
          done: Boolean(reminder.done),
          source: 'memory-cue-mobile',
        });

        try {
          for (let index = 0; index < reminders.length; index += chunkSize) {
            const slice = reminders.slice(index, index + chunkSize);
            const results = await Promise.allSettled(slice.map((reminder) => (
              fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(makePayload(reminder)),
              })
            )));

            results.forEach((result) => {
              if (result.status === 'fulfilled' && result.value?.ok) {
                okCount += 1;
              } else if (result.status === 'fulfilled') {
                failCount += 1;
              } else {
                failCount += 1;
              }
            });

            await new Promise((resolve) => setTimeout(resolve, 300));
          }

          if (!failCount) {
            setStatus('online', `Sync complete. ${okCount} updated.`);
          } else if (!okCount) {
            setStatus('error', 'Sync failed. Check your sync URL and retry.');
          } else {
            setStatus('error', `Partial sync: ${okCount} success, ${failCount} failed.`);
          }
        } catch (error) {
          console.error('Sync failed', error);
          setStatus('error', 'Sync failed. Try again soon.');
        } finally {
          toggleBusy(false);
        }
      });
    })();
  </script>
  
</body>
</html>
